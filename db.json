{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/2020年阅读总结.md","hash":"e3d090b133f8fd42c62aa15a97678860e6fc5ba8","modified":1688473570184},{"_id":"source/_posts/AKS中重写规则踩坑小记录.md","hash":"1146c4ee448d30991c41c5b2c89f1548fc02ed43","modified":1688473570184},{"_id":"source/_posts/lagrange项目回顾.md","hash":"83b2e41ee2cb3834a3d5b20b034213e1e9418b40","modified":1688473570184},{"_id":"source/_posts/Lagrange项目回顾2.md","hash":"16e7a0542731087dfada583e5dceb1b46af826a2","modified":1688473570184},{"_id":"source/_posts/hot-to-install-nodejs-nginx-mongodb-on-ubuntu.md","hash":"cca9fcdfbb51a60cef2a99bd06fd95668a9cacd1","modified":1688473570184},{"_id":"source/_posts/Spring-Cloud-Kubernetes环境下使用Jasypt.md","hash":"52f29fdff63a43375c40c45e0bfa556d1b1f3499","modified":1688473570184},{"_id":"source/_posts/重学Java-一-泛型.md","hash":"5c97652e0b36fe6a0dd346d343e6275d18d3bd22","modified":1688473570184},{"_id":"source/_posts/阿里云Kubernetes上线踩坑记.md","hash":"ced83ac649849463488e9eb627908587ac319231","modified":1688473570184},{"_id":"source/images/avatar.jpeg","hash":"7f4209a3e844b9184a97df2dd127c6e872e7d4f0","modified":1688473570185},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003831},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003837},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003842},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003846},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003854},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003716},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003760},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003788},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003814},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688474003827},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"635402ea312dfe670bafc736328b9788b993a500","modified":1688474003906},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1688474003866},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1688474003934},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1688474003883},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1688474003857},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":1688474003935},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1688474003890},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":1688474003958},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":1688474003958},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":1688474003959},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":1688474003959},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":1688474003960},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":1688474003960},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":1688474003960},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":1688474003962},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":1688474003961},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":1688474003961},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":1688474003963},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":1688474003964},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":1688474003961},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":1688474003962},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1688474003917},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1688474003920},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1688474003921},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1688474003925},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":1688474003926},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1688474003927},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1688474003885},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1688474003887},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1688474003892},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1688474003903},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1688474003928},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1688474003932},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1688474003868},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1688474003933},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1688474003891},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1688474003944},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"be25e890113e926bbac3bf1461d7ce5427914774","modified":1688474003943},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1688474003945},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1688474003945},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1688474003945},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1688474003950},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1688474003949},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1688474003951},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"dc98160142c95ef81ba4789351002a5fcf29c04c","modified":1688474003952},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1688474003950},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1688474003953},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1688474003954},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"0720a70448ffd78800f7556a7d67300eac19aa87","modified":1688474003955},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1688474003954},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1688474003951},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"85d13095ed49e3bb362fbac830df63fc416e79bf","modified":1688474003918},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1688474003922},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1688474003921},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1688474003923},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"bcee2e258d13af6ac439ee6adaeefc06ea384e7e","modified":1688474003925},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1688474003926},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1688474003928},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1688474003930},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1688474003933},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1688474003931},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1688474003915},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1688474003929},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1688474003932},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1688474003920},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1688474003948},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1688474003949},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1688474003954},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1688474003938},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1688474003956},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1688474003955},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1688474003956},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1688474003940},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1688474003957},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1688474003860},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":1688474003898},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1688474003903},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"bd30bd9ffc84e88e704384acdfcaab09019a744f","modified":1688474003901},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1688474003904},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1688474003905},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1688474003908},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1688474003905},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1688474003911},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1688474003862},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1688474003861},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1688474003911},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1688474003912},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1688474003895},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1688474003899},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1688474003913},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1688474003912},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1688474003909},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1688474003888},{"_id":"source/_drafts/H项目心路历程记-前言.md","hash":"eb016ea7cb134b6c23b7fef2b44ec76e9e85f2c4","modified":1688624864700},{"_id":"source/_drafts/H项目心路历程记(一).md","hash":"4164dde5b5224970a8c48a4aac4b31bb5f1dc43a","modified":1688973275769},{"_id":"source/_posts/H项目心路历程记-1.md","hash":"bd2c4b2c23ee2f91ce0551306bc9e40e5fe26663","modified":1688980621579}],"Category":[{"name":"杂记","_id":"cljo9zkjo00024goi1kpe1pou"},{"name":"后端","_id":"cljo9zkjq00074goifz3v6gea"},{"name":"设计","_id":"cljo9zkjs000d4goi3nzx2545"},{"name":"Cloud","parent":"cljo9zkjq00074goifz3v6gea","_id":"cljo9zkjt000p4goi5v02detb"}],"Data":[],"Page":[],"Post":[{"title":"2020年阅读总结","date":"2020-12-29T02:45:41.000Z","_content":"\n\n多灾多难的2020年已经没有几天了，整个2020年要说还真是像一记刹车，去年很多想法，计划都有因为疫情原因搁置了。平时的生活更是从宅家变成了重度宅家的状态，自然就多出了许多大段大段的连续时间，可以用来好好玩玩大作，看看小说。仔细盘点一下今年总共看了10本小说外加2本科普书籍( [2020年阅读书单](https://github.com/hashmaparraylist/ReadList/blob/master/ReadList2020.md)\n)，算是自2018年以来读书最多的一个年份了。其中不乏拖了近3年的那本《西方文化中的数学》。接着就来絮叨絮叨今年看的这12本书吧。\n\n---\n\n> 《莱博维茨的赞歌》\n\n第一次被安利《莱博维茨的赞歌》的机核的电台节目[辐射－视觉、音乐以及文学](https://www.gcores.com/radios/16773), 当时听完节目就相当好奇，可以被一部载入史册的CRPG游戏誉为精神文本的小说到底是个什么样子的。但是当时新星版的译本几乎就是绝本了，某鱼的二手价也要已经飙到了3位数。直到今年年初在核市节目上听到了中信版译本的消息,才有机会买来拜读。\n\n全书通过3个故事讲述了核战灭世后莱博维茨修道院从保卫文明，到重建，然后看着文明再度毁灭的故事。各种无不透露着辐射那股 `War, War never changed`的味道。\n\n> 《占星术杀人事件》《屋顶上的小丑》《亿男》\n\n这3本书都是2019年上海书展上买的。前两本都是岛田庄司的推理名篇，其中《占星术杀人事件》在本格派推理史上有着非凡的地位，各种被抄袭从未被超越过。《屋顶上的小丑》要是最吸引人的话就是多线叙事，每条线都掐在恰如其分的地方。《亿男》则是挂着悬疑羊头卖着人生哲理。\n\n> 《神经漫游者》\n\n威廉吉布森的蔓生三部曲之一，开创了赛博朋克的科幻流派，说实话这本书我看的很痛苦，很多地方实在读不懂，到现在我还是不明白那些无法读懂的地方到底是原著如此，还是翻译的不行，亦或者是Kindle版排版太烂了。\n\n> 《神们自己》，《神的九十亿个名字》\n\n阿瑟克拉克的中篇小说和短篇小说集，这两本书阅读体验奇佳，尤其是在读完《神经漫游者》后，虽然三本书被Amazon打在同一个包里来卖的，但是光从排版上就比《神经漫游者》高出不少，所以才会有我对后者排版问题的质疑。\n\n《神们自己》三线叙事，讲述了2个平行宇宙中的2个物种在能源，种族存续，家庭伦理上的各种讨论和故事。 《神的九十亿个名字》作为短篇小说集收录了好几篇风格题材迥异的小说，花上十几分钟读上一个故事是相当惬意的。\n\n> 《佐伊的战争》 《人类决裂》 《万物的终结》\n\n约翰斯卡尔齐的《老人的战争》系列的后3部，前三部大概是3，4年前读的吧，在这个宇宙观里最吸引人的设定就绿皮的人类防卫军战士，以及跨种族间的政治斗争。系列的六本书相当于在这个大设定下讲的六个故事。每个故事虽说都是独立的故事，但是前后皆有关联，而且最重要的就是每本的长度都算不上很长，相当适合于一口气读完。\n\n> 《西方文化中的数学》\n\n这本书大概是从2017年开始读的，当时意气奋发觉得对于理科生出身的我，书中内容应该很好理解，没想到最后不光是文化还是数学读的都是一知半解。只能说自大了。\n\n> 《一想到还有95%的问题留给人类，我就放心了》\n\n大概是18年还是19年前后对量子物理和宇宙物理开始有了兴趣，虽然各中理论并不是很了解，但是仍然很好奇的买了这本书，全书插画相当有趣，同时使用浅显易懂的语言来解释各种复杂的物理现象，以及当今人类物理知识的边界。强烈推荐给想假装成学霸的朋友。\n\n---\n\n> 2021年读什么\n\n具体读啥还没想好基本上还是以科幻和悬疑为主，但是肯定会读的应该有海明威的《丧钟为谁而鸣》和小林泰三的《醉步男》吧。\n\n","source":"_posts/2020年阅读总结.md","raw":"---\ntitle: 2020年阅读总结\ntags:\n  - 阅读\ncategories:\n  - 杂记\ndate: 2020-12-29 10:45:41\n---\n\n\n多灾多难的2020年已经没有几天了，整个2020年要说还真是像一记刹车，去年很多想法，计划都有因为疫情原因搁置了。平时的生活更是从宅家变成了重度宅家的状态，自然就多出了许多大段大段的连续时间，可以用来好好玩玩大作，看看小说。仔细盘点一下今年总共看了10本小说外加2本科普书籍( [2020年阅读书单](https://github.com/hashmaparraylist/ReadList/blob/master/ReadList2020.md)\n)，算是自2018年以来读书最多的一个年份了。其中不乏拖了近3年的那本《西方文化中的数学》。接着就来絮叨絮叨今年看的这12本书吧。\n\n---\n\n> 《莱博维茨的赞歌》\n\n第一次被安利《莱博维茨的赞歌》的机核的电台节目[辐射－视觉、音乐以及文学](https://www.gcores.com/radios/16773), 当时听完节目就相当好奇，可以被一部载入史册的CRPG游戏誉为精神文本的小说到底是个什么样子的。但是当时新星版的译本几乎就是绝本了，某鱼的二手价也要已经飙到了3位数。直到今年年初在核市节目上听到了中信版译本的消息,才有机会买来拜读。\n\n全书通过3个故事讲述了核战灭世后莱博维茨修道院从保卫文明，到重建，然后看着文明再度毁灭的故事。各种无不透露着辐射那股 `War, War never changed`的味道。\n\n> 《占星术杀人事件》《屋顶上的小丑》《亿男》\n\n这3本书都是2019年上海书展上买的。前两本都是岛田庄司的推理名篇，其中《占星术杀人事件》在本格派推理史上有着非凡的地位，各种被抄袭从未被超越过。《屋顶上的小丑》要是最吸引人的话就是多线叙事，每条线都掐在恰如其分的地方。《亿男》则是挂着悬疑羊头卖着人生哲理。\n\n> 《神经漫游者》\n\n威廉吉布森的蔓生三部曲之一，开创了赛博朋克的科幻流派，说实话这本书我看的很痛苦，很多地方实在读不懂，到现在我还是不明白那些无法读懂的地方到底是原著如此，还是翻译的不行，亦或者是Kindle版排版太烂了。\n\n> 《神们自己》，《神的九十亿个名字》\n\n阿瑟克拉克的中篇小说和短篇小说集，这两本书阅读体验奇佳，尤其是在读完《神经漫游者》后，虽然三本书被Amazon打在同一个包里来卖的，但是光从排版上就比《神经漫游者》高出不少，所以才会有我对后者排版问题的质疑。\n\n《神们自己》三线叙事，讲述了2个平行宇宙中的2个物种在能源，种族存续，家庭伦理上的各种讨论和故事。 《神的九十亿个名字》作为短篇小说集收录了好几篇风格题材迥异的小说，花上十几分钟读上一个故事是相当惬意的。\n\n> 《佐伊的战争》 《人类决裂》 《万物的终结》\n\n约翰斯卡尔齐的《老人的战争》系列的后3部，前三部大概是3，4年前读的吧，在这个宇宙观里最吸引人的设定就绿皮的人类防卫军战士，以及跨种族间的政治斗争。系列的六本书相当于在这个大设定下讲的六个故事。每个故事虽说都是独立的故事，但是前后皆有关联，而且最重要的就是每本的长度都算不上很长，相当适合于一口气读完。\n\n> 《西方文化中的数学》\n\n这本书大概是从2017年开始读的，当时意气奋发觉得对于理科生出身的我，书中内容应该很好理解，没想到最后不光是文化还是数学读的都是一知半解。只能说自大了。\n\n> 《一想到还有95%的问题留给人类，我就放心了》\n\n大概是18年还是19年前后对量子物理和宇宙物理开始有了兴趣，虽然各中理论并不是很了解，但是仍然很好奇的买了这本书，全书插画相当有趣，同时使用浅显易懂的语言来解释各种复杂的物理现象，以及当今人类物理知识的边界。强烈推荐给想假装成学霸的朋友。\n\n---\n\n> 2021年读什么\n\n具体读啥还没想好基本上还是以科幻和悬疑为主，但是肯定会读的应该有海明威的《丧钟为谁而鸣》和小林泰三的《醉步男》吧。\n\n","slug":"2020年阅读总结","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjl00004goifkkd2ktv","content":"<p>多灾多难的2020年已经没有几天了，整个2020年要说还真是像一记刹车，去年很多想法，计划都有因为疫情原因搁置了。平时的生活更是从宅家变成了重度宅家的状态，自然就多出了许多大段大段的连续时间，可以用来好好玩玩大作，看看小说。仔细盘点一下今年总共看了10本小说外加2本科普书籍( <a href=\"https://github.com/hashmaparraylist/ReadList/blob/master/ReadList2020.md\">2020年阅读书单</a><br>)，算是自2018年以来读书最多的一个年份了。其中不乏拖了近3年的那本《西方文化中的数学》。接着就来絮叨絮叨今年看的这12本书吧。</p>\n<hr>\n<blockquote>\n<p>《莱博维茨的赞歌》</p>\n</blockquote>\n<p>第一次被安利《莱博维茨的赞歌》的机核的电台节目<a href=\"https://www.gcores.com/radios/16773\">辐射－视觉、音乐以及文学</a>, 当时听完节目就相当好奇，可以被一部载入史册的CRPG游戏誉为精神文本的小说到底是个什么样子的。但是当时新星版的译本几乎就是绝本了，某鱼的二手价也要已经飙到了3位数。直到今年年初在核市节目上听到了中信版译本的消息,才有机会买来拜读。</p>\n<p>全书通过3个故事讲述了核战灭世后莱博维茨修道院从保卫文明，到重建，然后看着文明再度毁灭的故事。各种无不透露着辐射那股 <code>War, War never changed</code>的味道。</p>\n<blockquote>\n<p>《占星术杀人事件》《屋顶上的小丑》《亿男》</p>\n</blockquote>\n<p>这3本书都是2019年上海书展上买的。前两本都是岛田庄司的推理名篇，其中《占星术杀人事件》在本格派推理史上有着非凡的地位，各种被抄袭从未被超越过。《屋顶上的小丑》要是最吸引人的话就是多线叙事，每条线都掐在恰如其分的地方。《亿男》则是挂着悬疑羊头卖着人生哲理。</p>\n<blockquote>\n<p>《神经漫游者》</p>\n</blockquote>\n<p>威廉吉布森的蔓生三部曲之一，开创了赛博朋克的科幻流派，说实话这本书我看的很痛苦，很多地方实在读不懂，到现在我还是不明白那些无法读懂的地方到底是原著如此，还是翻译的不行，亦或者是Kindle版排版太烂了。</p>\n<blockquote>\n<p>《神们自己》，《神的九十亿个名字》</p>\n</blockquote>\n<p>阿瑟克拉克的中篇小说和短篇小说集，这两本书阅读体验奇佳，尤其是在读完《神经漫游者》后，虽然三本书被Amazon打在同一个包里来卖的，但是光从排版上就比《神经漫游者》高出不少，所以才会有我对后者排版问题的质疑。</p>\n<p>《神们自己》三线叙事，讲述了2个平行宇宙中的2个物种在能源，种族存续，家庭伦理上的各种讨论和故事。 《神的九十亿个名字》作为短篇小说集收录了好几篇风格题材迥异的小说，花上十几分钟读上一个故事是相当惬意的。</p>\n<blockquote>\n<p>《佐伊的战争》 《人类决裂》 《万物的终结》</p>\n</blockquote>\n<p>约翰斯卡尔齐的《老人的战争》系列的后3部，前三部大概是3，4年前读的吧，在这个宇宙观里最吸引人的设定就绿皮的人类防卫军战士，以及跨种族间的政治斗争。系列的六本书相当于在这个大设定下讲的六个故事。每个故事虽说都是独立的故事，但是前后皆有关联，而且最重要的就是每本的长度都算不上很长，相当适合于一口气读完。</p>\n<blockquote>\n<p>《西方文化中的数学》</p>\n</blockquote>\n<p>这本书大概是从2017年开始读的，当时意气奋发觉得对于理科生出身的我，书中内容应该很好理解，没想到最后不光是文化还是数学读的都是一知半解。只能说自大了。</p>\n<blockquote>\n<p>《一想到还有95%的问题留给人类，我就放心了》</p>\n</blockquote>\n<p>大概是18年还是19年前后对量子物理和宇宙物理开始有了兴趣，虽然各中理论并不是很了解，但是仍然很好奇的买了这本书，全书插画相当有趣，同时使用浅显易懂的语言来解释各种复杂的物理现象，以及当今人类物理知识的边界。强烈推荐给想假装成学霸的朋友。</p>\n<hr>\n<blockquote>\n<p>2021年读什么</p>\n</blockquote>\n<p>具体读啥还没想好基本上还是以科幻和悬疑为主，但是肯定会读的应该有海明威的《丧钟为谁而鸣》和小林泰三的《醉步男》吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>多灾多难的2020年已经没有几天了，整个2020年要说还真是像一记刹车，去年很多想法，计划都有因为疫情原因搁置了。平时的生活更是从宅家变成了重度宅家的状态，自然就多出了许多大段大段的连续时间，可以用来好好玩玩大作，看看小说。仔细盘点一下今年总共看了10本小说外加2本科普书籍( <a href=\"https://github.com/hashmaparraylist/ReadList/blob/master/ReadList2020.md\">2020年阅读书单</a><br>)，算是自2018年以来读书最多的一个年份了。其中不乏拖了近3年的那本《西方文化中的数学》。接着就来絮叨絮叨今年看的这12本书吧。</p>\n<hr>\n<blockquote>\n<p>《莱博维茨的赞歌》</p>\n</blockquote>\n<p>第一次被安利《莱博维茨的赞歌》的机核的电台节目<a href=\"https://www.gcores.com/radios/16773\">辐射－视觉、音乐以及文学</a>, 当时听完节目就相当好奇，可以被一部载入史册的CRPG游戏誉为精神文本的小说到底是个什么样子的。但是当时新星版的译本几乎就是绝本了，某鱼的二手价也要已经飙到了3位数。直到今年年初在核市节目上听到了中信版译本的消息,才有机会买来拜读。</p>\n<p>全书通过3个故事讲述了核战灭世后莱博维茨修道院从保卫文明，到重建，然后看着文明再度毁灭的故事。各种无不透露着辐射那股 <code>War, War never changed</code>的味道。</p>\n<blockquote>\n<p>《占星术杀人事件》《屋顶上的小丑》《亿男》</p>\n</blockquote>\n<p>这3本书都是2019年上海书展上买的。前两本都是岛田庄司的推理名篇，其中《占星术杀人事件》在本格派推理史上有着非凡的地位，各种被抄袭从未被超越过。《屋顶上的小丑》要是最吸引人的话就是多线叙事，每条线都掐在恰如其分的地方。《亿男》则是挂着悬疑羊头卖着人生哲理。</p>\n<blockquote>\n<p>《神经漫游者》</p>\n</blockquote>\n<p>威廉吉布森的蔓生三部曲之一，开创了赛博朋克的科幻流派，说实话这本书我看的很痛苦，很多地方实在读不懂，到现在我还是不明白那些无法读懂的地方到底是原著如此，还是翻译的不行，亦或者是Kindle版排版太烂了。</p>\n<blockquote>\n<p>《神们自己》，《神的九十亿个名字》</p>\n</blockquote>\n<p>阿瑟克拉克的中篇小说和短篇小说集，这两本书阅读体验奇佳，尤其是在读完《神经漫游者》后，虽然三本书被Amazon打在同一个包里来卖的，但是光从排版上就比《神经漫游者》高出不少，所以才会有我对后者排版问题的质疑。</p>\n<p>《神们自己》三线叙事，讲述了2个平行宇宙中的2个物种在能源，种族存续，家庭伦理上的各种讨论和故事。 《神的九十亿个名字》作为短篇小说集收录了好几篇风格题材迥异的小说，花上十几分钟读上一个故事是相当惬意的。</p>\n<blockquote>\n<p>《佐伊的战争》 《人类决裂》 《万物的终结》</p>\n</blockquote>\n<p>约翰斯卡尔齐的《老人的战争》系列的后3部，前三部大概是3，4年前读的吧，在这个宇宙观里最吸引人的设定就绿皮的人类防卫军战士，以及跨种族间的政治斗争。系列的六本书相当于在这个大设定下讲的六个故事。每个故事虽说都是独立的故事，但是前后皆有关联，而且最重要的就是每本的长度都算不上很长，相当适合于一口气读完。</p>\n<blockquote>\n<p>《西方文化中的数学》</p>\n</blockquote>\n<p>这本书大概是从2017年开始读的，当时意气奋发觉得对于理科生出身的我，书中内容应该很好理解，没想到最后不光是文化还是数学读的都是一知半解。只能说自大了。</p>\n<blockquote>\n<p>《一想到还有95%的问题留给人类，我就放心了》</p>\n</blockquote>\n<p>大概是18年还是19年前后对量子物理和宇宙物理开始有了兴趣，虽然各中理论并不是很了解，但是仍然很好奇的买了这本书，全书插画相当有趣，同时使用浅显易懂的语言来解释各种复杂的物理现象，以及当今人类物理知识的边界。强烈推荐给想假装成学霸的朋友。</p>\n<hr>\n<blockquote>\n<p>2021年读什么</p>\n</blockquote>\n<p>具体读啥还没想好基本上还是以科幻和悬疑为主，但是肯定会读的应该有海明威的《丧钟为谁而鸣》和小林泰三的《醉步男》吧。</p>\n"},{"title":"AKS中重写规则踩坑小记录","date":"2022-09-23T05:51:49.000Z","_content":"\n# 前言\n\n最近在做标准产品在不同云平台中的部署验证，有幸体验了一下微软的Azure。负责采购的运维部门这次采用了`Application Gateway`来搭配`AKS`(`Azure Kubernetes Service`)对外暴露服务，正好借着这个机会来体验一下`Application Gateway`。\n\n# 应用场景\n\n1. 域名`api.demo.com`指向`Application Gateway`的IP地址\n2. 在`AKS`内部2个Service, `gateway-service`和`backend-service`分别需要通过`Application Gateway`对外暴露。\n3. `/gateway/`指向`gateway-service`, 然后`/backend/`指向`backend-service`。而且两个Service都没有context-path，所以需要做一个Rewrite重写URI到Service的根目录上。\n\n# 定义重写集\n\n打开`AKS`对应的应用程序网关`设置` > `重写`。选择`添加重写集`。在`1. 名称和关联`这个Tab上只需要填写名称这项即可(名称后面在做ingress时需要使用), `关联的传递规则`不需要选择。`2. 重写规则配置`里添加一个重写规则，然后填上重写规则的名称，并添加条件(默认新建重写规则时，只会生成操作，不会生成条件)\n\n## `条件`做如下设置\n\n- **要检查的变量类型** : `服务器变量`\n- **服务器变量**: `request_uri`\n- **区分大小写**: `否` \n- **运算符**: `等号(=)`\n- **要匹配的模式**: `/(gateway|backend)/?(.*)`\n\n## `操作`做如下设置\n\n- **重写类型**: `URL`\n- **操作类型**: `设置`\n- **组件**: `URL路径和URL查询字符串`\n- **URL路径值**: `/{var_request_uri_2}`\n- **重新计算路径映射**: `不选中`\n- **URL查询字符串值**: `留空不设值`\n\n## 特殊说明\n\n`操作`里的`URL路径值`不能使用正则表达式GROUP替换组，例如`$1`和`$2`之类的。Azure自己定义了一套对应的替换组命名规则。具体可以参考这个网页[使用应用程序网关重写 HTTP 标头和 URL](https://docs.azure.cn/zh-cn/application-gateway/rewrite-http-headers-url)。\n\n另外一个需要注意一点，如果在`条件`里选择了`服务器变量`的`request_uri`的时候，注意这个`request_uri`是完整的原始请求URI(携带了查询参数)。例如: 在请求`http://api.demo.com/gateway/search?foo=bar&hello=world`中，`request_uri`的值将为`/gateway/search?foo=bar&hello=world`。由于`request_uri`里包含了查询参数，所以在`操作`的`组件`中建议勾选`URL路径和URL查询字符串`。如果只选择`URL路径`的情况下可能出现无法预期的错误。以我们上述的配置来说明。\n\n对象URL: `http://api.demo.com/gateway/search?foo=bar&hello=world`\n\n**组件** | `URL路径和URL查询字符串` | `URL路径`\n--- | --- | ---\n**结果** | `/search?foo=bar&hello=world` | `/search?foo=bar&hello=world?foo=bar&hello=world`\n\n# `ACK`的Ingress设置\n\n当选择了`Application Gateway`作为对外暴露Service的方式时，Kubernetes集群里(`kube-system`命名空间里)多一个`Application Gateway Ingress Controller`(Azure工单时通常会简称为`agic`)的Deployment,所以对外暴露服务时可以像传统`nginx ingress controller`一样添加一个`Ingress`对象即可(甚至配置也和ngic大致相同，只是多了2个annotations)\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    # 这里指定重写规则集(不是重写规则的名字)\n    appgw.ingress.kubernetes.io/rewrite-rule-set: rule-backend\n    # 指定说明你这里ingress的类型是agic\n    kubernetes.io/ingress.class: azure/application-gateway\n  name: backend-ingress\n  namespace: default\nspec:\n  rules:\n  - host: api.demo.com\n    http:\n      paths:\n      - backend:\n          service:\n            name: gateway-service\n            port:\n              number: 8080\n        path: /gateway/\n        pathType: Prefix\n      - backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080\n        path: /backend/\n        pathType: Prefix\n```\n\n# 总结\n\n由于微软云这块文档有部分缺失，导致在配置这块花了一点时间去排查，甚至开了工单。总结下来Ingress的配置主要是根据请求路径路由到对应的Service，重写规则集才是实际负责根据正则来进行匹配重写。","source":"_posts/AKS中重写规则踩坑小记录.md","raw":"---\ntitle: AKS中重写规则踩坑小记录\ndate: 2022-09-23 13:51:49\ntags:\n  - Aliyun\n  - Kubernetes\ncategories:\n  - 后端\n  - Cloud\n---\n\n# 前言\n\n最近在做标准产品在不同云平台中的部署验证，有幸体验了一下微软的Azure。负责采购的运维部门这次采用了`Application Gateway`来搭配`AKS`(`Azure Kubernetes Service`)对外暴露服务，正好借着这个机会来体验一下`Application Gateway`。\n\n# 应用场景\n\n1. 域名`api.demo.com`指向`Application Gateway`的IP地址\n2. 在`AKS`内部2个Service, `gateway-service`和`backend-service`分别需要通过`Application Gateway`对外暴露。\n3. `/gateway/`指向`gateway-service`, 然后`/backend/`指向`backend-service`。而且两个Service都没有context-path，所以需要做一个Rewrite重写URI到Service的根目录上。\n\n# 定义重写集\n\n打开`AKS`对应的应用程序网关`设置` > `重写`。选择`添加重写集`。在`1. 名称和关联`这个Tab上只需要填写名称这项即可(名称后面在做ingress时需要使用), `关联的传递规则`不需要选择。`2. 重写规则配置`里添加一个重写规则，然后填上重写规则的名称，并添加条件(默认新建重写规则时，只会生成操作，不会生成条件)\n\n## `条件`做如下设置\n\n- **要检查的变量类型** : `服务器变量`\n- **服务器变量**: `request_uri`\n- **区分大小写**: `否` \n- **运算符**: `等号(=)`\n- **要匹配的模式**: `/(gateway|backend)/?(.*)`\n\n## `操作`做如下设置\n\n- **重写类型**: `URL`\n- **操作类型**: `设置`\n- **组件**: `URL路径和URL查询字符串`\n- **URL路径值**: `/{var_request_uri_2}`\n- **重新计算路径映射**: `不选中`\n- **URL查询字符串值**: `留空不设值`\n\n## 特殊说明\n\n`操作`里的`URL路径值`不能使用正则表达式GROUP替换组，例如`$1`和`$2`之类的。Azure自己定义了一套对应的替换组命名规则。具体可以参考这个网页[使用应用程序网关重写 HTTP 标头和 URL](https://docs.azure.cn/zh-cn/application-gateway/rewrite-http-headers-url)。\n\n另外一个需要注意一点，如果在`条件`里选择了`服务器变量`的`request_uri`的时候，注意这个`request_uri`是完整的原始请求URI(携带了查询参数)。例如: 在请求`http://api.demo.com/gateway/search?foo=bar&hello=world`中，`request_uri`的值将为`/gateway/search?foo=bar&hello=world`。由于`request_uri`里包含了查询参数，所以在`操作`的`组件`中建议勾选`URL路径和URL查询字符串`。如果只选择`URL路径`的情况下可能出现无法预期的错误。以我们上述的配置来说明。\n\n对象URL: `http://api.demo.com/gateway/search?foo=bar&hello=world`\n\n**组件** | `URL路径和URL查询字符串` | `URL路径`\n--- | --- | ---\n**结果** | `/search?foo=bar&hello=world` | `/search?foo=bar&hello=world?foo=bar&hello=world`\n\n# `ACK`的Ingress设置\n\n当选择了`Application Gateway`作为对外暴露Service的方式时，Kubernetes集群里(`kube-system`命名空间里)多一个`Application Gateway Ingress Controller`(Azure工单时通常会简称为`agic`)的Deployment,所以对外暴露服务时可以像传统`nginx ingress controller`一样添加一个`Ingress`对象即可(甚至配置也和ngic大致相同，只是多了2个annotations)\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    # 这里指定重写规则集(不是重写规则的名字)\n    appgw.ingress.kubernetes.io/rewrite-rule-set: rule-backend\n    # 指定说明你这里ingress的类型是agic\n    kubernetes.io/ingress.class: azure/application-gateway\n  name: backend-ingress\n  namespace: default\nspec:\n  rules:\n  - host: api.demo.com\n    http:\n      paths:\n      - backend:\n          service:\n            name: gateway-service\n            port:\n              number: 8080\n        path: /gateway/\n        pathType: Prefix\n      - backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080\n        path: /backend/\n        pathType: Prefix\n```\n\n# 总结\n\n由于微软云这块文档有部分缺失，导致在配置这块花了一点时间去排查，甚至开了工单。总结下来Ingress的配置主要是根据请求路径路由到对应的Service，重写规则集才是实际负责根据正则来进行匹配重写。","slug":"AKS中重写规则踩坑小记录","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjn00014goi59hyfxy3","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在做标准产品在不同云平台中的部署验证，有幸体验了一下微软的Azure。负责采购的运维部门这次采用了<code>Application Gateway</code>来搭配<code>AKS</code>(<code>Azure Kubernetes Service</code>)对外暴露服务，正好借着这个机会来体验一下<code>Application Gateway</code>。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><ol>\n<li>域名<code>api.demo.com</code>指向<code>Application Gateway</code>的IP地址</li>\n<li>在<code>AKS</code>内部2个Service, <code>gateway-service</code>和<code>backend-service</code>分别需要通过<code>Application Gateway</code>对外暴露。</li>\n<li><code>/gateway/</code>指向<code>gateway-service</code>, 然后<code>/backend/</code>指向<code>backend-service</code>。而且两个Service都没有context-path，所以需要做一个Rewrite重写URI到Service的根目录上。</li>\n</ol>\n<h1 id=\"定义重写集\"><a href=\"#定义重写集\" class=\"headerlink\" title=\"定义重写集\"></a>定义重写集</h1><p>打开<code>AKS</code>对应的应用程序网关<code>设置</code> &gt; <code>重写</code>。选择<code>添加重写集</code>。在<code>1. 名称和关联</code>这个Tab上只需要填写名称这项即可(名称后面在做ingress时需要使用), <code>关联的传递规则</code>不需要选择。<code>2. 重写规则配置</code>里添加一个重写规则，然后填上重写规则的名称，并添加条件(默认新建重写规则时，只会生成操作，不会生成条件)</p>\n<h2 id=\"条件做如下设置\"><a href=\"#条件做如下设置\" class=\"headerlink\" title=\"条件做如下设置\"></a><code>条件</code>做如下设置</h2><ul>\n<li><strong>要检查的变量类型</strong> : <code>服务器变量</code></li>\n<li><strong>服务器变量</strong>: <code>request_uri</code></li>\n<li><strong>区分大小写</strong>: <code>否</code> </li>\n<li><strong>运算符</strong>: <code>等号(=)</code></li>\n<li><strong>要匹配的模式</strong>: <code>/(gateway|backend)/?(.*)</code></li>\n</ul>\n<h2 id=\"操作做如下设置\"><a href=\"#操作做如下设置\" class=\"headerlink\" title=\"操作做如下设置\"></a><code>操作</code>做如下设置</h2><ul>\n<li><strong>重写类型</strong>: <code>URL</code></li>\n<li><strong>操作类型</strong>: <code>设置</code></li>\n<li><strong>组件</strong>: <code>URL路径和URL查询字符串</code></li>\n<li><strong>URL路径值</strong>: <code>/&#123;var_request_uri_2&#125;</code></li>\n<li><strong>重新计算路径映射</strong>: <code>不选中</code></li>\n<li><strong>URL查询字符串值</strong>: <code>留空不设值</code></li>\n</ul>\n<h2 id=\"特殊说明\"><a href=\"#特殊说明\" class=\"headerlink\" title=\"特殊说明\"></a>特殊说明</h2><p><code>操作</code>里的<code>URL路径值</code>不能使用正则表达式GROUP替换组，例如<code>$1</code>和<code>$2</code>之类的。Azure自己定义了一套对应的替换组命名规则。具体可以参考这个网页<a href=\"https://docs.azure.cn/zh-cn/application-gateway/rewrite-http-headers-url\">使用应用程序网关重写 HTTP 标头和 URL</a>。</p>\n<p>另外一个需要注意一点，如果在<code>条件</code>里选择了<code>服务器变量</code>的<code>request_uri</code>的时候，注意这个<code>request_uri</code>是完整的原始请求URI(携带了查询参数)。例如: 在请求<code>http://api.demo.com/gateway/search?foo=bar&amp;hello=world</code>中，<code>request_uri</code>的值将为<code>/gateway/search?foo=bar&amp;hello=world</code>。由于<code>request_uri</code>里包含了查询参数，所以在<code>操作</code>的<code>组件</code>中建议勾选<code>URL路径和URL查询字符串</code>。如果只选择<code>URL路径</code>的情况下可能出现无法预期的错误。以我们上述的配置来说明。</p>\n<p>对象URL: <code>http://api.demo.com/gateway/search?foo=bar&amp;hello=world</code></p>\n<table>\n<thead>\n<tr>\n<th><strong>组件</strong></th>\n<th><code>URL路径和URL查询字符串</code></th>\n<th><code>URL路径</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>结果</strong></td>\n<td><code>/search?foo=bar&amp;hello=world</code></td>\n<td><code>/search?foo=bar&amp;hello=world?foo=bar&amp;hello=world</code></td>\n</tr>\n</tbody></table>\n<h1 id=\"ACK的Ingress设置\"><a href=\"#ACK的Ingress设置\" class=\"headerlink\" title=\"ACK的Ingress设置\"></a><code>ACK</code>的Ingress设置</h1><p>当选择了<code>Application Gateway</code>作为对外暴露Service的方式时，Kubernetes集群里(<code>kube-system</code>命名空间里)多一个<code>Application Gateway Ingress Controller</code>(Azure工单时通常会简称为<code>agic</code>)的Deployment,所以对外暴露服务时可以像传统<code>nginx ingress controller</code>一样添加一个<code>Ingress</code>对象即可(甚至配置也和ngic大致相同，只是多了2个annotations)</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里指定重写规则集(不是重写规则的名字)</span></span><br><span class=\"line\">    <span class=\"attr\">appgw.ingress.kubernetes.io/rewrite-rule-set:</span> <span class=\"string\">rule-backend</span></span><br><span class=\"line\">    <span class=\"comment\"># 指定说明你这里ingress的类型是agic</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/ingress.class:</span> <span class=\"string\">azure/application-gateway</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">backend-ingress</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">api.demo.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">gateway-service</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/gateway/</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">backend-service</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/backend/</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>由于微软云这块文档有部分缺失，导致在配置这块花了一点时间去排查，甚至开了工单。总结下来Ingress的配置主要是根据请求路径路由到对应的Service，重写规则集才是实际负责根据正则来进行匹配重写。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在做标准产品在不同云平台中的部署验证，有幸体验了一下微软的Azure。负责采购的运维部门这次采用了<code>Application Gateway</code>来搭配<code>AKS</code>(<code>Azure Kubernetes Service</code>)对外暴露服务，正好借着这个机会来体验一下<code>Application Gateway</code>。</p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><ol>\n<li>域名<code>api.demo.com</code>指向<code>Application Gateway</code>的IP地址</li>\n<li>在<code>AKS</code>内部2个Service, <code>gateway-service</code>和<code>backend-service</code>分别需要通过<code>Application Gateway</code>对外暴露。</li>\n<li><code>/gateway/</code>指向<code>gateway-service</code>, 然后<code>/backend/</code>指向<code>backend-service</code>。而且两个Service都没有context-path，所以需要做一个Rewrite重写URI到Service的根目录上。</li>\n</ol>\n<h1 id=\"定义重写集\"><a href=\"#定义重写集\" class=\"headerlink\" title=\"定义重写集\"></a>定义重写集</h1><p>打开<code>AKS</code>对应的应用程序网关<code>设置</code> &gt; <code>重写</code>。选择<code>添加重写集</code>。在<code>1. 名称和关联</code>这个Tab上只需要填写名称这项即可(名称后面在做ingress时需要使用), <code>关联的传递规则</code>不需要选择。<code>2. 重写规则配置</code>里添加一个重写规则，然后填上重写规则的名称，并添加条件(默认新建重写规则时，只会生成操作，不会生成条件)</p>\n<h2 id=\"条件做如下设置\"><a href=\"#条件做如下设置\" class=\"headerlink\" title=\"条件做如下设置\"></a><code>条件</code>做如下设置</h2><ul>\n<li><strong>要检查的变量类型</strong> : <code>服务器变量</code></li>\n<li><strong>服务器变量</strong>: <code>request_uri</code></li>\n<li><strong>区分大小写</strong>: <code>否</code> </li>\n<li><strong>运算符</strong>: <code>等号(=)</code></li>\n<li><strong>要匹配的模式</strong>: <code>/(gateway|backend)/?(.*)</code></li>\n</ul>\n<h2 id=\"操作做如下设置\"><a href=\"#操作做如下设置\" class=\"headerlink\" title=\"操作做如下设置\"></a><code>操作</code>做如下设置</h2><ul>\n<li><strong>重写类型</strong>: <code>URL</code></li>\n<li><strong>操作类型</strong>: <code>设置</code></li>\n<li><strong>组件</strong>: <code>URL路径和URL查询字符串</code></li>\n<li><strong>URL路径值</strong>: <code>/&#123;var_request_uri_2&#125;</code></li>\n<li><strong>重新计算路径映射</strong>: <code>不选中</code></li>\n<li><strong>URL查询字符串值</strong>: <code>留空不设值</code></li>\n</ul>\n<h2 id=\"特殊说明\"><a href=\"#特殊说明\" class=\"headerlink\" title=\"特殊说明\"></a>特殊说明</h2><p><code>操作</code>里的<code>URL路径值</code>不能使用正则表达式GROUP替换组，例如<code>$1</code>和<code>$2</code>之类的。Azure自己定义了一套对应的替换组命名规则。具体可以参考这个网页<a href=\"https://docs.azure.cn/zh-cn/application-gateway/rewrite-http-headers-url\">使用应用程序网关重写 HTTP 标头和 URL</a>。</p>\n<p>另外一个需要注意一点，如果在<code>条件</code>里选择了<code>服务器变量</code>的<code>request_uri</code>的时候，注意这个<code>request_uri</code>是完整的原始请求URI(携带了查询参数)。例如: 在请求<code>http://api.demo.com/gateway/search?foo=bar&amp;hello=world</code>中，<code>request_uri</code>的值将为<code>/gateway/search?foo=bar&amp;hello=world</code>。由于<code>request_uri</code>里包含了查询参数，所以在<code>操作</code>的<code>组件</code>中建议勾选<code>URL路径和URL查询字符串</code>。如果只选择<code>URL路径</code>的情况下可能出现无法预期的错误。以我们上述的配置来说明。</p>\n<p>对象URL: <code>http://api.demo.com/gateway/search?foo=bar&amp;hello=world</code></p>\n<table>\n<thead>\n<tr>\n<th><strong>组件</strong></th>\n<th><code>URL路径和URL查询字符串</code></th>\n<th><code>URL路径</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>结果</strong></td>\n<td><code>/search?foo=bar&amp;hello=world</code></td>\n<td><code>/search?foo=bar&amp;hello=world?foo=bar&amp;hello=world</code></td>\n</tr>\n</tbody></table>\n<h1 id=\"ACK的Ingress设置\"><a href=\"#ACK的Ingress设置\" class=\"headerlink\" title=\"ACK的Ingress设置\"></a><code>ACK</code>的Ingress设置</h1><p>当选择了<code>Application Gateway</code>作为对外暴露Service的方式时，Kubernetes集群里(<code>kube-system</code>命名空间里)多一个<code>Application Gateway Ingress Controller</code>(Azure工单时通常会简称为<code>agic</code>)的Deployment,所以对外暴露服务时可以像传统<code>nginx ingress controller</code>一样添加一个<code>Ingress</code>对象即可(甚至配置也和ngic大致相同，只是多了2个annotations)</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">networking.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Ingress</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">annotations:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里指定重写规则集(不是重写规则的名字)</span></span><br><span class=\"line\">    <span class=\"attr\">appgw.ingress.kubernetes.io/rewrite-rule-set:</span> <span class=\"string\">rule-backend</span></span><br><span class=\"line\">    <span class=\"comment\"># 指定说明你这里ingress的类型是agic</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/ingress.class:</span> <span class=\"string\">azure/application-gateway</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">backend-ingress</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">host:</span> <span class=\"string\">api.demo.com</span></span><br><span class=\"line\">    <span class=\"attr\">http:</span></span><br><span class=\"line\">      <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">gateway-service</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/gateway/</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">backend:</span></span><br><span class=\"line\">          <span class=\"attr\">service:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">backend-service</span></span><br><span class=\"line\">            <span class=\"attr\">port:</span></span><br><span class=\"line\">              <span class=\"attr\">number:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/backend/</span></span><br><span class=\"line\">        <span class=\"attr\">pathType:</span> <span class=\"string\">Prefix</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>由于微软云这块文档有部分缺失，导致在配置这块花了一点时间去排查，甚至开了工单。总结下来Ingress的配置主要是根据请求路径路由到对应的Service，重写规则集才是实际负责根据正则来进行匹配重写。</p>\n"},{"title":"Largrange项目架构与设计回顾 (二)","date":"2020-05-21T02:49:41.000Z","_content":"\n\n在[Largrange项目架构与设计回顾 (一)](/2020/05/09/lagrange项目回顾/) 里面我讲了一下项目开始架构和技术选型的一些内容。这一章来聊聊业务设计上的这点事。\n\n总体来说项目设计的时候,我们对业务模块的划分和拆解总体上来说都是遵循着高内聚,低耦合的原则来进行划分的。大部分和业务相关的服务,都还是能很好的进行功能划分的。但是有一些和具体业务关联性并不是很高的服务在界定与实现时出现了一些问题。\n\n## 任务调度服务\n\n由于平台方面会有一些控制命令下发给Android设备,而且下发的命令并不一定都是实时的,大部分都是指定一个时间来下发,所以在设计的时候就考虑到需要一个任务调度服务(以下略称`cron`),来处理这些下发指令以及未来可能会有的定时批处理任务的业务需求。技术选型的时候考虑到整个服务是构建在Kubernetes上的一个分布式的微服务架构,所以就没有选择Spring Scheduler,而是使用了Quarter来支撑整个`cron`。 \n\n从技术选型上来说`cron`没有什么问题,但是在设计如何使用`cron`上还是有点问题的, 我们先来看看已推送服务为例,整个平台中`cron`的处理流程是怎样的。\n\n1. `Platform` 调用 `cron`的创建定时任务Job的接口(接口的参数为推送时使用的相关参数)\n2. `cron` 创建Quartz的Job和Trigger,并将Job和Trigger的Name(Quartz中Job和Trigger的唯一标识符)返回个`Platform`\n3. `cron` 在指定时间触发推送的Job,即调用`Push`服务的推送接口\n4. `Push`的推送接口调用第三方服务商的推送服务,并将第三方推送服务的调用结果返回给`cron`\n5. `cron`通过调用`Platform`预留的推送服务回调地址将第三方推送服务调用接口返还给`Platform`\n6. `Platform` 将第三方推送服务的调用结果留档保存,并继续业务处理\n\n设计之初考虑到不想在`cron`中牵扯到具体的业务, 所以设计了一个`Platform`的回调接口来处理推送后的具体业务处理。虽然保证了`cron`尽量减少了和业务逻辑接触与数据库的访问。但是前前后后要访问集群内部的其他微服务2次,额外增加了网络开销,以及因为网络通信造成额外的通信失败风险。而且针对每种不同的定时任务,都需要额外开发一个QuartzJobBean,很难形成统一的QuartzJobBean来进行处理。今后如果还有相似项目还是需要重新考量一下如何设计一个更加完善的定时任务。\n\n## 总结\n\n暂时就想到了这些东西,今后想到啥还会继续在这里补存。\n","source":"_posts/Lagrange项目回顾2.md","raw":"---\ntitle: Largrange项目架构与设计回顾 (二)\ntags:\n  - 架构\n  - Kubernetes\n  - Aliyun\n  - Java\ncategories:\n  - 设计\ndate: 2020-05-21 10:49:41\n---\n\n\n在[Largrange项目架构与设计回顾 (一)](/2020/05/09/lagrange项目回顾/) 里面我讲了一下项目开始架构和技术选型的一些内容。这一章来聊聊业务设计上的这点事。\n\n总体来说项目设计的时候,我们对业务模块的划分和拆解总体上来说都是遵循着高内聚,低耦合的原则来进行划分的。大部分和业务相关的服务,都还是能很好的进行功能划分的。但是有一些和具体业务关联性并不是很高的服务在界定与实现时出现了一些问题。\n\n## 任务调度服务\n\n由于平台方面会有一些控制命令下发给Android设备,而且下发的命令并不一定都是实时的,大部分都是指定一个时间来下发,所以在设计的时候就考虑到需要一个任务调度服务(以下略称`cron`),来处理这些下发指令以及未来可能会有的定时批处理任务的业务需求。技术选型的时候考虑到整个服务是构建在Kubernetes上的一个分布式的微服务架构,所以就没有选择Spring Scheduler,而是使用了Quarter来支撑整个`cron`。 \n\n从技术选型上来说`cron`没有什么问题,但是在设计如何使用`cron`上还是有点问题的, 我们先来看看已推送服务为例,整个平台中`cron`的处理流程是怎样的。\n\n1. `Platform` 调用 `cron`的创建定时任务Job的接口(接口的参数为推送时使用的相关参数)\n2. `cron` 创建Quartz的Job和Trigger,并将Job和Trigger的Name(Quartz中Job和Trigger的唯一标识符)返回个`Platform`\n3. `cron` 在指定时间触发推送的Job,即调用`Push`服务的推送接口\n4. `Push`的推送接口调用第三方服务商的推送服务,并将第三方推送服务的调用结果返回给`cron`\n5. `cron`通过调用`Platform`预留的推送服务回调地址将第三方推送服务调用接口返还给`Platform`\n6. `Platform` 将第三方推送服务的调用结果留档保存,并继续业务处理\n\n设计之初考虑到不想在`cron`中牵扯到具体的业务, 所以设计了一个`Platform`的回调接口来处理推送后的具体业务处理。虽然保证了`cron`尽量减少了和业务逻辑接触与数据库的访问。但是前前后后要访问集群内部的其他微服务2次,额外增加了网络开销,以及因为网络通信造成额外的通信失败风险。而且针对每种不同的定时任务,都需要额外开发一个QuartzJobBean,很难形成统一的QuartzJobBean来进行处理。今后如果还有相似项目还是需要重新考量一下如何设计一个更加完善的定时任务。\n\n## 总结\n\n暂时就想到了这些东西,今后想到啥还会继续在这里补存。\n","slug":"Lagrange项目回顾2","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjp00044goibj6kewct","content":"<p>在<a href=\"/2020/05/09/lagrange%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/\">Largrange项目架构与设计回顾 (一)</a> 里面我讲了一下项目开始架构和技术选型的一些内容。这一章来聊聊业务设计上的这点事。</p>\n<p>总体来说项目设计的时候,我们对业务模块的划分和拆解总体上来说都是遵循着高内聚,低耦合的原则来进行划分的。大部分和业务相关的服务,都还是能很好的进行功能划分的。但是有一些和具体业务关联性并不是很高的服务在界定与实现时出现了一些问题。</p>\n<h2 id=\"任务调度服务\"><a href=\"#任务调度服务\" class=\"headerlink\" title=\"任务调度服务\"></a>任务调度服务</h2><p>由于平台方面会有一些控制命令下发给Android设备,而且下发的命令并不一定都是实时的,大部分都是指定一个时间来下发,所以在设计的时候就考虑到需要一个任务调度服务(以下略称<code>cron</code>),来处理这些下发指令以及未来可能会有的定时批处理任务的业务需求。技术选型的时候考虑到整个服务是构建在Kubernetes上的一个分布式的微服务架构,所以就没有选择Spring Scheduler,而是使用了Quarter来支撑整个<code>cron</code>。 </p>\n<p>从技术选型上来说<code>cron</code>没有什么问题,但是在设计如何使用<code>cron</code>上还是有点问题的, 我们先来看看已推送服务为例,整个平台中<code>cron</code>的处理流程是怎样的。</p>\n<ol>\n<li><code>Platform</code> 调用 <code>cron</code>的创建定时任务Job的接口(接口的参数为推送时使用的相关参数)</li>\n<li><code>cron</code> 创建Quartz的Job和Trigger,并将Job和Trigger的Name(Quartz中Job和Trigger的唯一标识符)返回个<code>Platform</code></li>\n<li><code>cron</code> 在指定时间触发推送的Job,即调用<code>Push</code>服务的推送接口</li>\n<li><code>Push</code>的推送接口调用第三方服务商的推送服务,并将第三方推送服务的调用结果返回给<code>cron</code></li>\n<li><code>cron</code>通过调用<code>Platform</code>预留的推送服务回调地址将第三方推送服务调用接口返还给<code>Platform</code></li>\n<li><code>Platform</code> 将第三方推送服务的调用结果留档保存,并继续业务处理</li>\n</ol>\n<p>设计之初考虑到不想在<code>cron</code>中牵扯到具体的业务, 所以设计了一个<code>Platform</code>的回调接口来处理推送后的具体业务处理。虽然保证了<code>cron</code>尽量减少了和业务逻辑接触与数据库的访问。但是前前后后要访问集群内部的其他微服务2次,额外增加了网络开销,以及因为网络通信造成额外的通信失败风险。而且针对每种不同的定时任务,都需要额外开发一个QuartzJobBean,很难形成统一的QuartzJobBean来进行处理。今后如果还有相似项目还是需要重新考量一下如何设计一个更加完善的定时任务。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>暂时就想到了这些东西,今后想到啥还会继续在这里补存。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"/2020/05/09/lagrange%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/\">Largrange项目架构与设计回顾 (一)</a> 里面我讲了一下项目开始架构和技术选型的一些内容。这一章来聊聊业务设计上的这点事。</p>\n<p>总体来说项目设计的时候,我们对业务模块的划分和拆解总体上来说都是遵循着高内聚,低耦合的原则来进行划分的。大部分和业务相关的服务,都还是能很好的进行功能划分的。但是有一些和具体业务关联性并不是很高的服务在界定与实现时出现了一些问题。</p>\n<h2 id=\"任务调度服务\"><a href=\"#任务调度服务\" class=\"headerlink\" title=\"任务调度服务\"></a>任务调度服务</h2><p>由于平台方面会有一些控制命令下发给Android设备,而且下发的命令并不一定都是实时的,大部分都是指定一个时间来下发,所以在设计的时候就考虑到需要一个任务调度服务(以下略称<code>cron</code>),来处理这些下发指令以及未来可能会有的定时批处理任务的业务需求。技术选型的时候考虑到整个服务是构建在Kubernetes上的一个分布式的微服务架构,所以就没有选择Spring Scheduler,而是使用了Quarter来支撑整个<code>cron</code>。 </p>\n<p>从技术选型上来说<code>cron</code>没有什么问题,但是在设计如何使用<code>cron</code>上还是有点问题的, 我们先来看看已推送服务为例,整个平台中<code>cron</code>的处理流程是怎样的。</p>\n<ol>\n<li><code>Platform</code> 调用 <code>cron</code>的创建定时任务Job的接口(接口的参数为推送时使用的相关参数)</li>\n<li><code>cron</code> 创建Quartz的Job和Trigger,并将Job和Trigger的Name(Quartz中Job和Trigger的唯一标识符)返回个<code>Platform</code></li>\n<li><code>cron</code> 在指定时间触发推送的Job,即调用<code>Push</code>服务的推送接口</li>\n<li><code>Push</code>的推送接口调用第三方服务商的推送服务,并将第三方推送服务的调用结果返回给<code>cron</code></li>\n<li><code>cron</code>通过调用<code>Platform</code>预留的推送服务回调地址将第三方推送服务调用接口返还给<code>Platform</code></li>\n<li><code>Platform</code> 将第三方推送服务的调用结果留档保存,并继续业务处理</li>\n</ol>\n<p>设计之初考虑到不想在<code>cron</code>中牵扯到具体的业务, 所以设计了一个<code>Platform</code>的回调接口来处理推送后的具体业务处理。虽然保证了<code>cron</code>尽量减少了和业务逻辑接触与数据库的访问。但是前前后后要访问集群内部的其他微服务2次,额外增加了网络开销,以及因为网络通信造成额外的通信失败风险。而且针对每种不同的定时任务,都需要额外开发一个QuartzJobBean,很难形成统一的QuartzJobBean来进行处理。今后如果还有相似项目还是需要重新考量一下如何设计一个更加完善的定时任务。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>暂时就想到了这些东西,今后想到啥还会继续在这里补存。</p>\n"},{"title":"Spring Cloud Kubernetes环境下使用Jasypt","date":"2021-09-29T03:28:11.000Z","_content":"\n\n# 前言\n\n最近半年着手开始做了基于微服务的中台项目，整个项目的技术栈采用的是`Java` + `Spring Cloud` + `Kubernetes` + `Istio`。\n\n业务开放上还是相当顺利的。但是在安全审核上，运维组提出了一个简易。现在项目一些敏感配置，例如MySQL用户的密码，Redis的密码等现在都是明文保存在Kubernetes的ConfigMap中的(是的，我们并没有Nacos作为微服务的配置中心)。这样可能存在安全隐患。\n\n# 首次尝试\n\n既然有问题，那就解决问题。要给配置文件中的属性项目加密很简单，稍微Google一下，就有现成的方案了。\n\n现在比较常用的解决方案就是集成`Jasypt`,然后通过`jasypt-spring-boot-starter`来融合进Spring。\n\n### POM包加入`jasypt-spring-boot-starter`\n\n```xml\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>3.0.4</version>\n</dependency>\n```\n\n### Dockerfile中增加java参数\n\n```\n...\nENTRYPOINT [\"sh\",\"-c\",\"java $JAVA_OPTS -jar app.jar --jasypt.encryptor.password=helloworld $PARAMS\"]\n```\n\n### 在ConfigMap中添加加密属性\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: demo\ndata:\n  application.yaml: |-\n    test2: ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\n```\n\n### 利用`actuator`接口测试\n\n在`management.endpoints.web.exposure.include`属性中增加`env`，这样我们就可以通过调用`/actuator/env`来查看一下`env`接口返回的整个Spring 容器中所有的PropertySource。\n\n```json\n{\n    ...\n    \"propertySources\": [\n        {\n            \"name\": \"bootstrapProperties-configmap.demo.default\",\n            \"properties\": {\n                \"test2\": {\n                    \"value\": \"Hello,world\"\n                }\n            }\n        }\n        ...\n    ]\n}\n```\n\nOK, 这下配置项已经加密了。问题解决了。\n\n但是...\n\n## 新的问题\n\n自从项目集成了`Jayspt`以后，出现了一个奇怪的问题。每次项目试图通过修改ConfigMap的配置文件，然后试图通过`spring-cloud-starter-kubernetes-fabric8-config`来做自动Reload，都失败了。然而查阅应用日志，并没有出现任何异常。无奈只能打开`spring-cloud`和`jasypt-spring-boot`的`DEBUG`日志。\n\n进过几天对日志和两边源代码的分析。终于找到了原因\n\n### 原因\n\n在Spring Boot启动时`jasypt-spring-boot`会将下面6种配置(并不仅限与这6种配置文件)\n\n- `Classpath`下的`application.yaml`\n- `Classpath`下的`bootstrap.yaml`\n- 集群里名称为`${spring.cloud.kubernetes.config.name}`的ConfigMap\n- 集群里名称为`${spring.cloud.kubernetes.config.name}-kubernetes`的ConfigMap\n- Java启动参数\n- 环境变量\n\n转换成`jasypt-spring-boot`自己的PropertySource实现类`EncryptableMapPropertySourceWrapper`。\n\n但是如果使用Kubernetes的ConfigMap来作微服务配置中心的时候，Spring Cloud会在`ConfigurationChangeDetector`中查找配置类`org.springframework.cloud.bootstrap.config.BootstrapPropertySource`, 并依据`BootstrapPropertySource`的类型来判断容器内的配置与集群中ConfigMap里的配置是否有差异,来触发配置reload。\n\n由于`jasypt-spring-boot`已经将所有的配置文件转型成了`EncryptableMapPropertySourceWrapper`, 所以`ConfigurationChangeDetector`无法找到`BootstrapPropertySource`所以会一直任务ConfigMap的里的配置没有变化，导致整个Reload失效(无论是使用polling还是event方式)\n\n### 解决问题\n\n为了保证ConfigMap变化后自动Reload的功能，所以`jasypt-spring-boot`不能把`BootstrapPropertySource`转换成`EncryptableMapPropertySourceWrapper`\n\n所以我们需要设置`jasypt.encryptor.skip-property-sources`配置项, Classpath中的application.yaml需要增加配置\n\n```yaml\njasypt:\n  encryptor:\n    skip-property-sources: org.springframework.cloud.bootstrap.config.BootstrapPropertySource\n```\n\n`skip-property-sources`配置项配置后，加密项目就不能配置在ConfigMap里了，毕竟已经被我们忽略了。那么我们只能另外找一个PropertySource来存放加密项目了。\n\n`Classpath`中的两个Yaml由于编译时会被Maven打包进Jar文件，会牵涉多个CI/CD多个流程显然不合适，启动参数配置项的也要影响到Docker镜像制作这个流程。所以判断下来最适合的PropertySource就是环境变量了。\n\n### 环境变量增加加密项\n\n在Kubernetes的部署Yaml中，添加加密数据项`application.test.str`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: demo\n  name: demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: demo\n  template:\n    metadata:\n      labels:\n        app: demo\n    spec:\n      containers:\n        - env:\n            - name: TZ\n              value: Asia/Shanghai\n            - name: application.test.str\n              value: >-\n                ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\n    ....\n```\n\n如果需要更加严密的加密方针的话，我们可以把环境变量的内容放进Kubernetes的Secrets中。\n\n### 在ConfigMap中引用`application.test.str`\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: demo\ndata:\n  application.yaml: |-\n    test2: ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\n    test3: ${application.test.str}\n```\n\n### 通过`actuator`接口来测试\n\n通过`actuator\\env`接口来测试一下\n\n```json\n{\n    ...\n    \"propertySources\": [\n        {\n            \"name\": \"bootstrapProperties-configmap.demo.default\",\n            \"properties\": {\n                \"test2\": {\n                    \"value\": \"ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\"\n                },\n                \"test3\": {\n                    \"value\": \"Hello,world\"\n                }\n            }\n        }\n        ...\n    ]\n}\n```\n\n这样ConfigMap中的配置项`test3`就可以通过环境变量引用并使用加密配置项了。同时修改ConfigMap依然可以触发auto reload了。这下终于算是解决了。","source":"_posts/Spring-Cloud-Kubernetes环境下使用Jasypt.md","raw":"---\ntitle: Spring Cloud Kubernetes环境下使用Jasypt\ntags:\n  - Java\n  - Spring\ncategories:\n  - 后端\ndate: 2021-09-29 11:28:11\n---\n\n\n# 前言\n\n最近半年着手开始做了基于微服务的中台项目，整个项目的技术栈采用的是`Java` + `Spring Cloud` + `Kubernetes` + `Istio`。\n\n业务开放上还是相当顺利的。但是在安全审核上，运维组提出了一个简易。现在项目一些敏感配置，例如MySQL用户的密码，Redis的密码等现在都是明文保存在Kubernetes的ConfigMap中的(是的，我们并没有Nacos作为微服务的配置中心)。这样可能存在安全隐患。\n\n# 首次尝试\n\n既然有问题，那就解决问题。要给配置文件中的属性项目加密很简单，稍微Google一下，就有现成的方案了。\n\n现在比较常用的解决方案就是集成`Jasypt`,然后通过`jasypt-spring-boot-starter`来融合进Spring。\n\n### POM包加入`jasypt-spring-boot-starter`\n\n```xml\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>3.0.4</version>\n</dependency>\n```\n\n### Dockerfile中增加java参数\n\n```\n...\nENTRYPOINT [\"sh\",\"-c\",\"java $JAVA_OPTS -jar app.jar --jasypt.encryptor.password=helloworld $PARAMS\"]\n```\n\n### 在ConfigMap中添加加密属性\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: demo\ndata:\n  application.yaml: |-\n    test2: ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\n```\n\n### 利用`actuator`接口测试\n\n在`management.endpoints.web.exposure.include`属性中增加`env`，这样我们就可以通过调用`/actuator/env`来查看一下`env`接口返回的整个Spring 容器中所有的PropertySource。\n\n```json\n{\n    ...\n    \"propertySources\": [\n        {\n            \"name\": \"bootstrapProperties-configmap.demo.default\",\n            \"properties\": {\n                \"test2\": {\n                    \"value\": \"Hello,world\"\n                }\n            }\n        }\n        ...\n    ]\n}\n```\n\nOK, 这下配置项已经加密了。问题解决了。\n\n但是...\n\n## 新的问题\n\n自从项目集成了`Jayspt`以后，出现了一个奇怪的问题。每次项目试图通过修改ConfigMap的配置文件，然后试图通过`spring-cloud-starter-kubernetes-fabric8-config`来做自动Reload，都失败了。然而查阅应用日志，并没有出现任何异常。无奈只能打开`spring-cloud`和`jasypt-spring-boot`的`DEBUG`日志。\n\n进过几天对日志和两边源代码的分析。终于找到了原因\n\n### 原因\n\n在Spring Boot启动时`jasypt-spring-boot`会将下面6种配置(并不仅限与这6种配置文件)\n\n- `Classpath`下的`application.yaml`\n- `Classpath`下的`bootstrap.yaml`\n- 集群里名称为`${spring.cloud.kubernetes.config.name}`的ConfigMap\n- 集群里名称为`${spring.cloud.kubernetes.config.name}-kubernetes`的ConfigMap\n- Java启动参数\n- 环境变量\n\n转换成`jasypt-spring-boot`自己的PropertySource实现类`EncryptableMapPropertySourceWrapper`。\n\n但是如果使用Kubernetes的ConfigMap来作微服务配置中心的时候，Spring Cloud会在`ConfigurationChangeDetector`中查找配置类`org.springframework.cloud.bootstrap.config.BootstrapPropertySource`, 并依据`BootstrapPropertySource`的类型来判断容器内的配置与集群中ConfigMap里的配置是否有差异,来触发配置reload。\n\n由于`jasypt-spring-boot`已经将所有的配置文件转型成了`EncryptableMapPropertySourceWrapper`, 所以`ConfigurationChangeDetector`无法找到`BootstrapPropertySource`所以会一直任务ConfigMap的里的配置没有变化，导致整个Reload失效(无论是使用polling还是event方式)\n\n### 解决问题\n\n为了保证ConfigMap变化后自动Reload的功能，所以`jasypt-spring-boot`不能把`BootstrapPropertySource`转换成`EncryptableMapPropertySourceWrapper`\n\n所以我们需要设置`jasypt.encryptor.skip-property-sources`配置项, Classpath中的application.yaml需要增加配置\n\n```yaml\njasypt:\n  encryptor:\n    skip-property-sources: org.springframework.cloud.bootstrap.config.BootstrapPropertySource\n```\n\n`skip-property-sources`配置项配置后，加密项目就不能配置在ConfigMap里了，毕竟已经被我们忽略了。那么我们只能另外找一个PropertySource来存放加密项目了。\n\n`Classpath`中的两个Yaml由于编译时会被Maven打包进Jar文件，会牵涉多个CI/CD多个流程显然不合适，启动参数配置项的也要影响到Docker镜像制作这个流程。所以判断下来最适合的PropertySource就是环境变量了。\n\n### 环境变量增加加密项\n\n在Kubernetes的部署Yaml中，添加加密数据项`application.test.str`\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: demo\n  name: demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: demo\n  template:\n    metadata:\n      labels:\n        app: demo\n    spec:\n      containers:\n        - env:\n            - name: TZ\n              value: Asia/Shanghai\n            - name: application.test.str\n              value: >-\n                ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\n    ....\n```\n\n如果需要更加严密的加密方针的话，我们可以把环境变量的内容放进Kubernetes的Secrets中。\n\n### 在ConfigMap中引用`application.test.str`\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: demo\ndata:\n  application.yaml: |-\n    test2: ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\n    test3: ${application.test.str}\n```\n\n### 通过`actuator`接口来测试\n\n通过`actuator\\env`接口来测试一下\n\n```json\n{\n    ...\n    \"propertySources\": [\n        {\n            \"name\": \"bootstrapProperties-configmap.demo.default\",\n            \"properties\": {\n                \"test2\": {\n                    \"value\": \"ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)\"\n                },\n                \"test3\": {\n                    \"value\": \"Hello,world\"\n                }\n            }\n        }\n        ...\n    ]\n}\n```\n\n这样ConfigMap中的配置项`test3`就可以通过环境变量引用并使用加密配置项了。同时修改ConfigMap依然可以触发auto reload了。这下终于算是解决了。","slug":"Spring-Cloud-Kubernetes环境下使用Jasypt","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjp00054goi3n9a45hn","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近半年着手开始做了基于微服务的中台项目，整个项目的技术栈采用的是<code>Java</code> + <code>Spring Cloud</code> + <code>Kubernetes</code> + <code>Istio</code>。</p>\n<p>业务开放上还是相当顺利的。但是在安全审核上，运维组提出了一个简易。现在项目一些敏感配置，例如MySQL用户的密码，Redis的密码等现在都是明文保存在Kubernetes的ConfigMap中的(是的，我们并没有Nacos作为微服务的配置中心)。这样可能存在安全隐患。</p>\n<h1 id=\"首次尝试\"><a href=\"#首次尝试\" class=\"headerlink\" title=\"首次尝试\"></a>首次尝试</h1><p>既然有问题，那就解决问题。要给配置文件中的属性项目加密很简单，稍微Google一下，就有现成的方案了。</p>\n<p>现在比较常用的解决方案就是集成<code>Jasypt</code>,然后通过<code>jasypt-spring-boot-starter</code>来融合进Spring。</p>\n<h3 id=\"POM包加入jasypt-spring-boot-starter\"><a href=\"#POM包加入jasypt-spring-boot-starter\" class=\"headerlink\" title=\"POM包加入jasypt-spring-boot-starter\"></a>POM包加入<code>jasypt-spring-boot-starter</code></h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.ulisesbocchio<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Dockerfile中增加java参数\"><a href=\"#Dockerfile中增加java参数\" class=\"headerlink\" title=\"Dockerfile中增加java参数\"></a>Dockerfile中增加java参数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">ENTRYPOINT [&quot;sh&quot;,&quot;-c&quot;,&quot;java $JAVA_OPTS -jar app.jar --jasypt.encryptor.password=helloworld $PARAMS&quot;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在ConfigMap中添加加密属性\"><a href=\"#在ConfigMap中添加加密属性\" class=\"headerlink\" title=\"在ConfigMap中添加加密属性\"></a>在ConfigMap中添加加密属性</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">demo</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">application.yaml:</span> <span class=\"string\">|-</span></span><br><span class=\"line\">    <span class=\"attr\">test2:</span> <span class=\"string\">ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用actuator接口测试\"><a href=\"#利用actuator接口测试\" class=\"headerlink\" title=\"利用actuator接口测试\"></a>利用<code>actuator</code>接口测试</h3><p>在<code>management.endpoints.web.exposure.include</code>属性中增加<code>env</code>，这样我们就可以通过调用<code>/actuator/env</code>来查看一下<code>env</code>接口返回的整个Spring 容器中所有的PropertySource。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"attr\">&quot;propertySources&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bootstrapProperties-configmap.demo.default&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;test2&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Hello,world&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>OK, 这下配置项已经加密了。问题解决了。</p>\n<p>但是…</p>\n<h2 id=\"新的问题\"><a href=\"#新的问题\" class=\"headerlink\" title=\"新的问题\"></a>新的问题</h2><p>自从项目集成了<code>Jayspt</code>以后，出现了一个奇怪的问题。每次项目试图通过修改ConfigMap的配置文件，然后试图通过<code>spring-cloud-starter-kubernetes-fabric8-config</code>来做自动Reload，都失败了。然而查阅应用日志，并没有出现任何异常。无奈只能打开<code>spring-cloud</code>和<code>jasypt-spring-boot</code>的<code>DEBUG</code>日志。</p>\n<p>进过几天对日志和两边源代码的分析。终于找到了原因</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>在Spring Boot启动时<code>jasypt-spring-boot</code>会将下面6种配置(并不仅限与这6种配置文件)</p>\n<ul>\n<li><code>Classpath</code>下的<code>application.yaml</code></li>\n<li><code>Classpath</code>下的<code>bootstrap.yaml</code></li>\n<li>集群里名称为<code>$&#123;spring.cloud.kubernetes.config.name&#125;</code>的ConfigMap</li>\n<li>集群里名称为<code>$&#123;spring.cloud.kubernetes.config.name&#125;-kubernetes</code>的ConfigMap</li>\n<li>Java启动参数</li>\n<li>环境变量</li>\n</ul>\n<p>转换成<code>jasypt-spring-boot</code>自己的PropertySource实现类<code>EncryptableMapPropertySourceWrapper</code>。</p>\n<p>但是如果使用Kubernetes的ConfigMap来作微服务配置中心的时候，Spring Cloud会在<code>ConfigurationChangeDetector</code>中查找配置类<code>org.springframework.cloud.bootstrap.config.BootstrapPropertySource</code>, 并依据<code>BootstrapPropertySource</code>的类型来判断容器内的配置与集群中ConfigMap里的配置是否有差异,来触发配置reload。</p>\n<p>由于<code>jasypt-spring-boot</code>已经将所有的配置文件转型成了<code>EncryptableMapPropertySourceWrapper</code>, 所以<code>ConfigurationChangeDetector</code>无法找到<code>BootstrapPropertySource</code>所以会一直任务ConfigMap的里的配置没有变化，导致整个Reload失效(无论是使用polling还是event方式)</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>为了保证ConfigMap变化后自动Reload的功能，所以<code>jasypt-spring-boot</code>不能把<code>BootstrapPropertySource</code>转换成<code>EncryptableMapPropertySourceWrapper</code></p>\n<p>所以我们需要设置<code>jasypt.encryptor.skip-property-sources</code>配置项, Classpath中的application.yaml需要增加配置</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jasypt:</span></span><br><span class=\"line\">  <span class=\"attr\">encryptor:</span></span><br><span class=\"line\">    <span class=\"attr\">skip-property-sources:</span> <span class=\"string\">org.springframework.cloud.bootstrap.config.BootstrapPropertySource</span></span><br></pre></td></tr></table></figure>\n\n<p><code>skip-property-sources</code>配置项配置后，加密项目就不能配置在ConfigMap里了，毕竟已经被我们忽略了。那么我们只能另外找一个PropertySource来存放加密项目了。</p>\n<p><code>Classpath</code>中的两个Yaml由于编译时会被Maven打包进Jar文件，会牵涉多个CI/CD多个流程显然不合适，启动参数配置项的也要影响到Docker镜像制作这个流程。所以判断下来最适合的PropertySource就是环境变量了。</p>\n<h3 id=\"环境变量增加加密项\"><a href=\"#环境变量增加加密项\" class=\"headerlink\" title=\"环境变量增加加密项\"></a>环境变量增加加密项</h3><p>在Kubernetes的部署Yaml中，添加加密数据项<code>application.test.str</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">demo</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TZ</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">application.test.str</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">&gt;-</span></span><br><span class=\"line\"><span class=\"string\">                ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"string\">....</span></span><br></pre></td></tr></table></figure>\n\n<p>如果需要更加严密的加密方针的话，我们可以把环境变量的内容放进Kubernetes的Secrets中。</p>\n<h3 id=\"在ConfigMap中引用application-test-str\"><a href=\"#在ConfigMap中引用application-test-str\" class=\"headerlink\" title=\"在ConfigMap中引用application.test.str\"></a>在ConfigMap中引用<code>application.test.str</code></h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">demo</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">application.yaml:</span> <span class=\"string\">|-</span></span><br><span class=\"line\"><span class=\"string\">    test2: ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)</span></span><br><span class=\"line\"><span class=\"string\">    test3: $&#123;application.test.str&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通过actuator接口来测试\"><a href=\"#通过actuator接口来测试\" class=\"headerlink\" title=\"通过actuator接口来测试\"></a>通过<code>actuator</code>接口来测试</h3><p>通过<code>actuator\\env</code>接口来测试一下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"attr\">&quot;propertySources&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bootstrapProperties-configmap.demo.default&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;test2&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;test3&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Hello,world&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样ConfigMap中的配置项<code>test3</code>就可以通过环境变量引用并使用加密配置项了。同时修改ConfigMap依然可以触发auto reload了。这下终于算是解决了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近半年着手开始做了基于微服务的中台项目，整个项目的技术栈采用的是<code>Java</code> + <code>Spring Cloud</code> + <code>Kubernetes</code> + <code>Istio</code>。</p>\n<p>业务开放上还是相当顺利的。但是在安全审核上，运维组提出了一个简易。现在项目一些敏感配置，例如MySQL用户的密码，Redis的密码等现在都是明文保存在Kubernetes的ConfigMap中的(是的，我们并没有Nacos作为微服务的配置中心)。这样可能存在安全隐患。</p>\n<h1 id=\"首次尝试\"><a href=\"#首次尝试\" class=\"headerlink\" title=\"首次尝试\"></a>首次尝试</h1><p>既然有问题，那就解决问题。要给配置文件中的属性项目加密很简单，稍微Google一下，就有现成的方案了。</p>\n<p>现在比较常用的解决方案就是集成<code>Jasypt</code>,然后通过<code>jasypt-spring-boot-starter</code>来融合进Spring。</p>\n<h3 id=\"POM包加入jasypt-spring-boot-starter\"><a href=\"#POM包加入jasypt-spring-boot-starter\" class=\"headerlink\" title=\"POM包加入jasypt-spring-boot-starter\"></a>POM包加入<code>jasypt-spring-boot-starter</code></h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.ulisesbocchio<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Dockerfile中增加java参数\"><a href=\"#Dockerfile中增加java参数\" class=\"headerlink\" title=\"Dockerfile中增加java参数\"></a>Dockerfile中增加java参数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">ENTRYPOINT [&quot;sh&quot;,&quot;-c&quot;,&quot;java $JAVA_OPTS -jar app.jar --jasypt.encryptor.password=helloworld $PARAMS&quot;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在ConfigMap中添加加密属性\"><a href=\"#在ConfigMap中添加加密属性\" class=\"headerlink\" title=\"在ConfigMap中添加加密属性\"></a>在ConfigMap中添加加密属性</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">demo</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">application.yaml:</span> <span class=\"string\">|-</span></span><br><span class=\"line\">    <span class=\"attr\">test2:</span> <span class=\"string\">ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用actuator接口测试\"><a href=\"#利用actuator接口测试\" class=\"headerlink\" title=\"利用actuator接口测试\"></a>利用<code>actuator</code>接口测试</h3><p>在<code>management.endpoints.web.exposure.include</code>属性中增加<code>env</code>，这样我们就可以通过调用<code>/actuator/env</code>来查看一下<code>env</code>接口返回的整个Spring 容器中所有的PropertySource。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"attr\">&quot;propertySources&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bootstrapProperties-configmap.demo.default&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;test2&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Hello,world&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>OK, 这下配置项已经加密了。问题解决了。</p>\n<p>但是…</p>\n<h2 id=\"新的问题\"><a href=\"#新的问题\" class=\"headerlink\" title=\"新的问题\"></a>新的问题</h2><p>自从项目集成了<code>Jayspt</code>以后，出现了一个奇怪的问题。每次项目试图通过修改ConfigMap的配置文件，然后试图通过<code>spring-cloud-starter-kubernetes-fabric8-config</code>来做自动Reload，都失败了。然而查阅应用日志，并没有出现任何异常。无奈只能打开<code>spring-cloud</code>和<code>jasypt-spring-boot</code>的<code>DEBUG</code>日志。</p>\n<p>进过几天对日志和两边源代码的分析。终于找到了原因</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>在Spring Boot启动时<code>jasypt-spring-boot</code>会将下面6种配置(并不仅限与这6种配置文件)</p>\n<ul>\n<li><code>Classpath</code>下的<code>application.yaml</code></li>\n<li><code>Classpath</code>下的<code>bootstrap.yaml</code></li>\n<li>集群里名称为<code>$&#123;spring.cloud.kubernetes.config.name&#125;</code>的ConfigMap</li>\n<li>集群里名称为<code>$&#123;spring.cloud.kubernetes.config.name&#125;-kubernetes</code>的ConfigMap</li>\n<li>Java启动参数</li>\n<li>环境变量</li>\n</ul>\n<p>转换成<code>jasypt-spring-boot</code>自己的PropertySource实现类<code>EncryptableMapPropertySourceWrapper</code>。</p>\n<p>但是如果使用Kubernetes的ConfigMap来作微服务配置中心的时候，Spring Cloud会在<code>ConfigurationChangeDetector</code>中查找配置类<code>org.springframework.cloud.bootstrap.config.BootstrapPropertySource</code>, 并依据<code>BootstrapPropertySource</code>的类型来判断容器内的配置与集群中ConfigMap里的配置是否有差异,来触发配置reload。</p>\n<p>由于<code>jasypt-spring-boot</code>已经将所有的配置文件转型成了<code>EncryptableMapPropertySourceWrapper</code>, 所以<code>ConfigurationChangeDetector</code>无法找到<code>BootstrapPropertySource</code>所以会一直任务ConfigMap的里的配置没有变化，导致整个Reload失效(无论是使用polling还是event方式)</p>\n<h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>为了保证ConfigMap变化后自动Reload的功能，所以<code>jasypt-spring-boot</code>不能把<code>BootstrapPropertySource</code>转换成<code>EncryptableMapPropertySourceWrapper</code></p>\n<p>所以我们需要设置<code>jasypt.encryptor.skip-property-sources</code>配置项, Classpath中的application.yaml需要增加配置</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jasypt:</span></span><br><span class=\"line\">  <span class=\"attr\">encryptor:</span></span><br><span class=\"line\">    <span class=\"attr\">skip-property-sources:</span> <span class=\"string\">org.springframework.cloud.bootstrap.config.BootstrapPropertySource</span></span><br></pre></td></tr></table></figure>\n\n<p><code>skip-property-sources</code>配置项配置后，加密项目就不能配置在ConfigMap里了，毕竟已经被我们忽略了。那么我们只能另外找一个PropertySource来存放加密项目了。</p>\n<p><code>Classpath</code>中的两个Yaml由于编译时会被Maven打包进Jar文件，会牵涉多个CI/CD多个流程显然不合适，启动参数配置项的也要影响到Docker镜像制作这个流程。所以判断下来最适合的PropertySource就是环境变量了。</p>\n<h3 id=\"环境变量增加加密项\"><a href=\"#环境变量增加加密项\" class=\"headerlink\" title=\"环境变量增加加密项\"></a>环境变量增加加密项</h3><p>在Kubernetes的部署Yaml中，添加加密数据项<code>application.test.str</code></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">demo</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TZ</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">application.test.str</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">&gt;-</span></span><br><span class=\"line\"><span class=\"string\">                ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)</span></span><br><span class=\"line\"><span class=\"string\"></span>    <span class=\"string\">....</span></span><br></pre></td></tr></table></figure>\n\n<p>如果需要更加严密的加密方针的话，我们可以把环境变量的内容放进Kubernetes的Secrets中。</p>\n<h3 id=\"在ConfigMap中引用application-test-str\"><a href=\"#在ConfigMap中引用application-test-str\" class=\"headerlink\" title=\"在ConfigMap中引用application.test.str\"></a>在ConfigMap中引用<code>application.test.str</code></h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">demo</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">application.yaml:</span> <span class=\"string\">|-</span></span><br><span class=\"line\"><span class=\"string\">    test2: ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)</span></span><br><span class=\"line\"><span class=\"string\">    test3: $&#123;application.test.str&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"通过actuator接口来测试\"><a href=\"#通过actuator接口来测试\" class=\"headerlink\" title=\"通过actuator接口来测试\"></a>通过<code>actuator</code>接口来测试</h3><p>通过<code>actuator\\env</code>接口来测试一下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"attr\">&quot;propertySources&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bootstrapProperties-configmap.demo.default&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;properties&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;test2&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ENC(94Y7Ds3+RKraxQQlura9sDx+9yF0zDLMGMwi2TjyCFZOkkHfreRFSb6fxbyvCKs7)&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;test3&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Hello,world&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样ConfigMap中的配置项<code>test3</code>就可以通过环境变量引用并使用加密配置项了。同时修改ConfigMap依然可以触发auto reload了。这下终于算是解决了。</p>\n"},{"title":"Largrange项目架构与设计回顾 (一)","date":"2020-05-09T02:34:47.000Z","_content":"\n\n> 项目背景\n\n从去年年底开始一个老客户希望在他们的一个传统的机械设备(后面略称 `E机关` )上外装一个Android设备。 Android设备和 `E机关` 之间通过串口或是RJ45接口进行数据交互，主要是Android设备获取 `E机关` 内部的数据，并不会通过接口来控制 `E机关` 。 Android设备则通过4G 来和平台交互，上报Android设备的状态数据，同时接受平台的控制。以此来实现让传统机械设备也能拥抱物联网的概念。\n\n最后围绕着客户的需求分成了3个项目来并行推进\n\n1. Android设备的硬件设备的设计、选材、样机制作与量产规划\n2. 在Android设备上,进行与`E机关`以及平台进行交互的APP开发\n3. 用于Android设备交互的平台的架构、设计与开发\n\n我们平台Team就负责 `3.用于Android设备交互的平台` 并命名Lagrange (拉格朗日) 。\n\n# 设计&架构\n\n整个平台这块不仅需要向Android设备的APP提供数据交互接口，还需要有一个供相关运营人员使用的前端Web应用，以及与云平台(主要是Aliyun) 交互的功能。所以考虑到多方面使用微服务的架构来实现整个平台端。\n由于`E机关`的工作工况不能保证长期较的稳定的连接到4G网络，所以我们并不考虑使用Socket长连接的方式来做APP和平台之间的数据交互，要实现平台对Android设备进行反控的话，只能实现推送方式来把控制命令下发给Android设备,所以还需要有一个第三方推送服务商交互的服务。同时控制推送也有实时和非实时以及定期推送的需求，所以可能还需要一个任务调度的服务。\n\n根据对上述业务进行梳理，我们将项目分成几个服务\n\n- 提供Android设备的交互接口的 `App Service`\n- 提供运营人员使用前端Web应用 `Platform Web Service`\n- 前端Web应用使用到的一些接口 `Platform Service`\n- 负责第三方推送服务商交互的 `Push Service`\n- 提供云平台鉴权用的 `Auth Service`\n- 用来管理任务调度的 `Cron Service`\n\n由于前一个项目实施的时候没有使用容器部署，每当访问量峰值的时候，我们这些码农兼运维就各种加班，所以这次项目决定直接将服务容器化，同时选择了`Kubernetes`来管理容器。由于客观原因线上的`Kubernetes`直接购买了Aliyun的托管版`Kubernetes`服务。 内部的开发测试环境则使用了 `Rancher 2.0` 来构建`Kubernetes`集群。\n\n\n# 技术选型\n\n## a. 后端服务选型\n\n由于不考虑长连接的原因，所以在后端服务在技术选型上基本就不考虑Netty了，直接上Spring大礼包。\n\n- Spring Boot 开发接口\n- Spring Data 配合 JPA 来进行数据的持久化\n- Spring Cloud Kubenetes 来做数据的Config的autoreload\n- Quartz 负责处理任务调度\n\n服务之间调用都使用HTTP服务, 服务发现也有`Kubernetes`的DNS机制支持。服务网格则选择了比较成熟的`Istio`，主要还是Aliyun的`Kubernetes`可以集成`Istio`，部署和使用都相当方便。\n\n## b. 前端Web应用选型\n\n因为前端Web应用主要是给运营人员使用，所以我们考虑使用Single Page Application来做个前后端分离的Web应用。框架这块由于团队成员基本上没有什么前端开发经验，基本都是后台写Java的码农，所以框架选择有点随性，直接就点名了vue.js。前端控件库则用的是阿里系的Antd。\n\n## c. 数据持久层\n\n主数据库选择了mysql，缓存用的redis。这些都是团队比较熟悉的。由于一些特殊的业务需求和使用场景，我们还加了一个mongodb来做为一个副数据库，主要存放一些特殊业务使用的数据。\n\n## d. DevOps\n\n用了相当传统的GitLab CE 加上Jenkins的组合，实现前后端代码的自动编译，推送到私有的镜像仓库(使用Aliyun的镜像仓库服务)\n\n# 最后\n\n以上基本是项目最早做设计时候的各种考量。暂时先写这么多，过两天再回顾一下当初设计上有哪些觉得不足的地方。\n\n","source":"_posts/lagrange项目回顾.md","raw":"---\ntitle: Largrange项目架构与设计回顾 (一)\ntags:\n  - 架构\n  - Kubernetes\n  - Aliyun\n  - Java\ncategories:\n  - 设计\ndate: 2020-05-09 10:34:47\n---\n\n\n> 项目背景\n\n从去年年底开始一个老客户希望在他们的一个传统的机械设备(后面略称 `E机关` )上外装一个Android设备。 Android设备和 `E机关` 之间通过串口或是RJ45接口进行数据交互，主要是Android设备获取 `E机关` 内部的数据，并不会通过接口来控制 `E机关` 。 Android设备则通过4G 来和平台交互，上报Android设备的状态数据，同时接受平台的控制。以此来实现让传统机械设备也能拥抱物联网的概念。\n\n最后围绕着客户的需求分成了3个项目来并行推进\n\n1. Android设备的硬件设备的设计、选材、样机制作与量产规划\n2. 在Android设备上,进行与`E机关`以及平台进行交互的APP开发\n3. 用于Android设备交互的平台的架构、设计与开发\n\n我们平台Team就负责 `3.用于Android设备交互的平台` 并命名Lagrange (拉格朗日) 。\n\n# 设计&架构\n\n整个平台这块不仅需要向Android设备的APP提供数据交互接口，还需要有一个供相关运营人员使用的前端Web应用，以及与云平台(主要是Aliyun) 交互的功能。所以考虑到多方面使用微服务的架构来实现整个平台端。\n由于`E机关`的工作工况不能保证长期较的稳定的连接到4G网络，所以我们并不考虑使用Socket长连接的方式来做APP和平台之间的数据交互，要实现平台对Android设备进行反控的话，只能实现推送方式来把控制命令下发给Android设备,所以还需要有一个第三方推送服务商交互的服务。同时控制推送也有实时和非实时以及定期推送的需求，所以可能还需要一个任务调度的服务。\n\n根据对上述业务进行梳理，我们将项目分成几个服务\n\n- 提供Android设备的交互接口的 `App Service`\n- 提供运营人员使用前端Web应用 `Platform Web Service`\n- 前端Web应用使用到的一些接口 `Platform Service`\n- 负责第三方推送服务商交互的 `Push Service`\n- 提供云平台鉴权用的 `Auth Service`\n- 用来管理任务调度的 `Cron Service`\n\n由于前一个项目实施的时候没有使用容器部署，每当访问量峰值的时候，我们这些码农兼运维就各种加班，所以这次项目决定直接将服务容器化，同时选择了`Kubernetes`来管理容器。由于客观原因线上的`Kubernetes`直接购买了Aliyun的托管版`Kubernetes`服务。 内部的开发测试环境则使用了 `Rancher 2.0` 来构建`Kubernetes`集群。\n\n\n# 技术选型\n\n## a. 后端服务选型\n\n由于不考虑长连接的原因，所以在后端服务在技术选型上基本就不考虑Netty了，直接上Spring大礼包。\n\n- Spring Boot 开发接口\n- Spring Data 配合 JPA 来进行数据的持久化\n- Spring Cloud Kubenetes 来做数据的Config的autoreload\n- Quartz 负责处理任务调度\n\n服务之间调用都使用HTTP服务, 服务发现也有`Kubernetes`的DNS机制支持。服务网格则选择了比较成熟的`Istio`，主要还是Aliyun的`Kubernetes`可以集成`Istio`，部署和使用都相当方便。\n\n## b. 前端Web应用选型\n\n因为前端Web应用主要是给运营人员使用，所以我们考虑使用Single Page Application来做个前后端分离的Web应用。框架这块由于团队成员基本上没有什么前端开发经验，基本都是后台写Java的码农，所以框架选择有点随性，直接就点名了vue.js。前端控件库则用的是阿里系的Antd。\n\n## c. 数据持久层\n\n主数据库选择了mysql，缓存用的redis。这些都是团队比较熟悉的。由于一些特殊的业务需求和使用场景，我们还加了一个mongodb来做为一个副数据库，主要存放一些特殊业务使用的数据。\n\n## d. DevOps\n\n用了相当传统的GitLab CE 加上Jenkins的组合，实现前后端代码的自动编译，推送到私有的镜像仓库(使用Aliyun的镜像仓库服务)\n\n# 最后\n\n以上基本是项目最早做设计时候的各种考量。暂时先写这么多，过两天再回顾一下当初设计上有哪些觉得不足的地方。\n\n","slug":"lagrange项目回顾","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjq00064goihyn69kzz","content":"<blockquote>\n<p>项目背景</p>\n</blockquote>\n<p>从去年年底开始一个老客户希望在他们的一个传统的机械设备(后面略称 <code>E机关</code> )上外装一个Android设备。 Android设备和 <code>E机关</code> 之间通过串口或是RJ45接口进行数据交互，主要是Android设备获取 <code>E机关</code> 内部的数据，并不会通过接口来控制 <code>E机关</code> 。 Android设备则通过4G 来和平台交互，上报Android设备的状态数据，同时接受平台的控制。以此来实现让传统机械设备也能拥抱物联网的概念。</p>\n<p>最后围绕着客户的需求分成了3个项目来并行推进</p>\n<ol>\n<li>Android设备的硬件设备的设计、选材、样机制作与量产规划</li>\n<li>在Android设备上,进行与<code>E机关</code>以及平台进行交互的APP开发</li>\n<li>用于Android设备交互的平台的架构、设计与开发</li>\n</ol>\n<p>我们平台Team就负责 <code>3.用于Android设备交互的平台</code> 并命名Lagrange (拉格朗日) 。</p>\n<h1 id=\"设计-amp-架构\"><a href=\"#设计-amp-架构\" class=\"headerlink\" title=\"设计&amp;架构\"></a>设计&amp;架构</h1><p>整个平台这块不仅需要向Android设备的APP提供数据交互接口，还需要有一个供相关运营人员使用的前端Web应用，以及与云平台(主要是Aliyun) 交互的功能。所以考虑到多方面使用微服务的架构来实现整个平台端。<br>由于<code>E机关</code>的工作工况不能保证长期较的稳定的连接到4G网络，所以我们并不考虑使用Socket长连接的方式来做APP和平台之间的数据交互，要实现平台对Android设备进行反控的话，只能实现推送方式来把控制命令下发给Android设备,所以还需要有一个第三方推送服务商交互的服务。同时控制推送也有实时和非实时以及定期推送的需求，所以可能还需要一个任务调度的服务。</p>\n<p>根据对上述业务进行梳理，我们将项目分成几个服务</p>\n<ul>\n<li>提供Android设备的交互接口的 <code>App Service</code></li>\n<li>提供运营人员使用前端Web应用 <code>Platform Web Service</code></li>\n<li>前端Web应用使用到的一些接口 <code>Platform Service</code></li>\n<li>负责第三方推送服务商交互的 <code>Push Service</code></li>\n<li>提供云平台鉴权用的 <code>Auth Service</code></li>\n<li>用来管理任务调度的 <code>Cron Service</code></li>\n</ul>\n<p>由于前一个项目实施的时候没有使用容器部署，每当访问量峰值的时候，我们这些码农兼运维就各种加班，所以这次项目决定直接将服务容器化，同时选择了<code>Kubernetes</code>来管理容器。由于客观原因线上的<code>Kubernetes</code>直接购买了Aliyun的托管版<code>Kubernetes</code>服务。 内部的开发测试环境则使用了 <code>Rancher 2.0</code> 来构建<code>Kubernetes</code>集群。</p>\n<h1 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h1><h2 id=\"a-后端服务选型\"><a href=\"#a-后端服务选型\" class=\"headerlink\" title=\"a. 后端服务选型\"></a>a. 后端服务选型</h2><p>由于不考虑长连接的原因，所以在后端服务在技术选型上基本就不考虑Netty了，直接上Spring大礼包。</p>\n<ul>\n<li>Spring Boot 开发接口</li>\n<li>Spring Data 配合 JPA 来进行数据的持久化</li>\n<li>Spring Cloud Kubenetes 来做数据的Config的autoreload</li>\n<li>Quartz 负责处理任务调度</li>\n</ul>\n<p>服务之间调用都使用HTTP服务, 服务发现也有<code>Kubernetes</code>的DNS机制支持。服务网格则选择了比较成熟的<code>Istio</code>，主要还是Aliyun的<code>Kubernetes</code>可以集成<code>Istio</code>，部署和使用都相当方便。</p>\n<h2 id=\"b-前端Web应用选型\"><a href=\"#b-前端Web应用选型\" class=\"headerlink\" title=\"b. 前端Web应用选型\"></a>b. 前端Web应用选型</h2><p>因为前端Web应用主要是给运营人员使用，所以我们考虑使用Single Page Application来做个前后端分离的Web应用。框架这块由于团队成员基本上没有什么前端开发经验，基本都是后台写Java的码农，所以框架选择有点随性，直接就点名了vue.js。前端控件库则用的是阿里系的Antd。</p>\n<h2 id=\"c-数据持久层\"><a href=\"#c-数据持久层\" class=\"headerlink\" title=\"c. 数据持久层\"></a>c. 数据持久层</h2><p>主数据库选择了mysql，缓存用的redis。这些都是团队比较熟悉的。由于一些特殊的业务需求和使用场景，我们还加了一个mongodb来做为一个副数据库，主要存放一些特殊业务使用的数据。</p>\n<h2 id=\"d-DevOps\"><a href=\"#d-DevOps\" class=\"headerlink\" title=\"d. DevOps\"></a>d. DevOps</h2><p>用了相当传统的GitLab CE 加上Jenkins的组合，实现前后端代码的自动编译，推送到私有的镜像仓库(使用Aliyun的镜像仓库服务)</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>以上基本是项目最早做设计时候的各种考量。暂时先写这么多，过两天再回顾一下当初设计上有哪些觉得不足的地方。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>项目背景</p>\n</blockquote>\n<p>从去年年底开始一个老客户希望在他们的一个传统的机械设备(后面略称 <code>E机关</code> )上外装一个Android设备。 Android设备和 <code>E机关</code> 之间通过串口或是RJ45接口进行数据交互，主要是Android设备获取 <code>E机关</code> 内部的数据，并不会通过接口来控制 <code>E机关</code> 。 Android设备则通过4G 来和平台交互，上报Android设备的状态数据，同时接受平台的控制。以此来实现让传统机械设备也能拥抱物联网的概念。</p>\n<p>最后围绕着客户的需求分成了3个项目来并行推进</p>\n<ol>\n<li>Android设备的硬件设备的设计、选材、样机制作与量产规划</li>\n<li>在Android设备上,进行与<code>E机关</code>以及平台进行交互的APP开发</li>\n<li>用于Android设备交互的平台的架构、设计与开发</li>\n</ol>\n<p>我们平台Team就负责 <code>3.用于Android设备交互的平台</code> 并命名Lagrange (拉格朗日) 。</p>\n<h1 id=\"设计-amp-架构\"><a href=\"#设计-amp-架构\" class=\"headerlink\" title=\"设计&amp;架构\"></a>设计&amp;架构</h1><p>整个平台这块不仅需要向Android设备的APP提供数据交互接口，还需要有一个供相关运营人员使用的前端Web应用，以及与云平台(主要是Aliyun) 交互的功能。所以考虑到多方面使用微服务的架构来实现整个平台端。<br>由于<code>E机关</code>的工作工况不能保证长期较的稳定的连接到4G网络，所以我们并不考虑使用Socket长连接的方式来做APP和平台之间的数据交互，要实现平台对Android设备进行反控的话，只能实现推送方式来把控制命令下发给Android设备,所以还需要有一个第三方推送服务商交互的服务。同时控制推送也有实时和非实时以及定期推送的需求，所以可能还需要一个任务调度的服务。</p>\n<p>根据对上述业务进行梳理，我们将项目分成几个服务</p>\n<ul>\n<li>提供Android设备的交互接口的 <code>App Service</code></li>\n<li>提供运营人员使用前端Web应用 <code>Platform Web Service</code></li>\n<li>前端Web应用使用到的一些接口 <code>Platform Service</code></li>\n<li>负责第三方推送服务商交互的 <code>Push Service</code></li>\n<li>提供云平台鉴权用的 <code>Auth Service</code></li>\n<li>用来管理任务调度的 <code>Cron Service</code></li>\n</ul>\n<p>由于前一个项目实施的时候没有使用容器部署，每当访问量峰值的时候，我们这些码农兼运维就各种加班，所以这次项目决定直接将服务容器化，同时选择了<code>Kubernetes</code>来管理容器。由于客观原因线上的<code>Kubernetes</code>直接购买了Aliyun的托管版<code>Kubernetes</code>服务。 内部的开发测试环境则使用了 <code>Rancher 2.0</code> 来构建<code>Kubernetes</code>集群。</p>\n<h1 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h1><h2 id=\"a-后端服务选型\"><a href=\"#a-后端服务选型\" class=\"headerlink\" title=\"a. 后端服务选型\"></a>a. 后端服务选型</h2><p>由于不考虑长连接的原因，所以在后端服务在技术选型上基本就不考虑Netty了，直接上Spring大礼包。</p>\n<ul>\n<li>Spring Boot 开发接口</li>\n<li>Spring Data 配合 JPA 来进行数据的持久化</li>\n<li>Spring Cloud Kubenetes 来做数据的Config的autoreload</li>\n<li>Quartz 负责处理任务调度</li>\n</ul>\n<p>服务之间调用都使用HTTP服务, 服务发现也有<code>Kubernetes</code>的DNS机制支持。服务网格则选择了比较成熟的<code>Istio</code>，主要还是Aliyun的<code>Kubernetes</code>可以集成<code>Istio</code>，部署和使用都相当方便。</p>\n<h2 id=\"b-前端Web应用选型\"><a href=\"#b-前端Web应用选型\" class=\"headerlink\" title=\"b. 前端Web应用选型\"></a>b. 前端Web应用选型</h2><p>因为前端Web应用主要是给运营人员使用，所以我们考虑使用Single Page Application来做个前后端分离的Web应用。框架这块由于团队成员基本上没有什么前端开发经验，基本都是后台写Java的码农，所以框架选择有点随性，直接就点名了vue.js。前端控件库则用的是阿里系的Antd。</p>\n<h2 id=\"c-数据持久层\"><a href=\"#c-数据持久层\" class=\"headerlink\" title=\"c. 数据持久层\"></a>c. 数据持久层</h2><p>主数据库选择了mysql，缓存用的redis。这些都是团队比较熟悉的。由于一些特殊的业务需求和使用场景，我们还加了一个mongodb来做为一个副数据库，主要存放一些特殊业务使用的数据。</p>\n<h2 id=\"d-DevOps\"><a href=\"#d-DevOps\" class=\"headerlink\" title=\"d. DevOps\"></a>d. DevOps</h2><p>用了相当传统的GitLab CE 加上Jenkins的组合，实现前后端代码的自动编译，推送到私有的镜像仓库(使用Aliyun的镜像仓库服务)</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>以上基本是项目最早做设计时候的各种考量。暂时先写这么多，过两天再回顾一下当初设计上有哪些觉得不足的地方。</p>\n"},{"title":"在ubuntu上从零搭建node.js + nginx + mongodb环境","date":"2019-12-09T02:40:05.000Z","_content":"\n\n说到后端开发环境，最有名的莫过于LAMP和LNMP，最近由于node.js的强势崛起，越来越多的后端开发也开始试水node.js了。我最近也因为各种原因，前前后后总够构建了好几台node.js + nginx + mongodb的Linux服务器。\n\n首先关于Linux服务器，比起CentOS来说，我更加喜欢ubuntu一点。所以无论是阿里云还是一些海外的vps服务器上，我也倾向选用ubuntu服务器，本贴也是基于ubuntu服务器里说明的。\n\n## 1.开始前的一些准备\n\n首先还是需要刷新一下ubuntu的包索引并安装build-essential和libssl-dev这2个包以及curl这个工具。\n\n```sh\nsudo apt-get update\nsudo apt-get install build-essential libssl-dev\nsudo apt-get isntall curl\n```\n\n## 2.安装node.js\n\n关于安装node.js这一点，我不是很推荐使用apt-get 来安装node.js的环境。主要是因为node.js和io.js合并以后，版本迭代速度相当频繁(主要还是因为更多ES6的特性得到了支持）。今后很有可能会有在一台服务器上使用不同版本的node.js的需求。\n\n这里推荐一个管理不同版本node.js的工具：nvm，官网: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)  。安装nvm，如果前面你安装了curl的话可以\n\n```sh\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash\n```\n如果没有按照curl的话，也可以使用wget来进行安装\n\n```sh\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash\n```\n\n然后nvm就会自动安装到home目录下面的.nvm目录里，并会在.bashrc里自动添加nvm的环境变量。为了让环境变量生效，最简单的方法就是通过ssh或是telnet重新连接你的服务器。\n\n安装完nvm后，就可以通过nvm来安装指定版本的node.js了。\n\n```sh\n# 列出可以安装的node版本号\nnvm ls-remote\n\n# 安装指定版本的node (当前最新版本为v5.7.1, LTS版是v4.3.2)\nnvm install v4.3.2\n```\n\n## 3.安装nginx\n\n由于ubuntu源（尤其是阿里云的源）上的nginx经常不是最新的，如果需要安装最新版本nginx的时候需要手动添加nginx的源。\n\n```sh\n# 添加nginx的mainline仓库\ncd /tmp/ && wget http://nginx.org/keys/nginx_signing.key\nsudo apt-key add nginx_signing.key\n\n# 编辑/etc/apt/sources.list.d/nginx.list 添加下面2行内容，井号不需要\n# deb http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx\n# deb-src http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx\nsudo vi  /etc/apt/sources.list.d/nginx.list\n\n# 更新源，并安装nginx\nsudo apt-get update && sudo apt-get install nginx\n```\n\n在编辑/etc/apt/sources.list.d/nginx.list的时候需要注意，“ubuntu代号”需要根据ubuntu服务器的版本不同手动调整的，比如14.04是trusty。通过下面的命令可以获取ubuntu的代号。\n```sh\nlsb_release -cs\n```\n\n## 4.安装mongodb\n\n同样和nginx有同样的问题，要安装最新3.2版本的mongodb也需要手动添加ubuntu的源。\n\n```sh\n# 导入mongodb的public key\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927\n\n# 生成mongodb的源list\necho \"deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list\n\n# 更新源\nsudo apt-get update\n\n# 安装最新版本的mongodb\nsudo apt-get install -y mongodb-org\n```\n\n以上一台node.js + nginx + mongodb的ubuntu服务器就完成了。\n\n","source":"_posts/hot-to-install-nodejs-nginx-mongodb-on-ubuntu.md","raw":"---\ntitle: 在ubuntu上从零搭建node.js + nginx + mongodb环境\ntags:\n  - ubuntu\n  - node.js\n  - nginx\n  - mongodb\ncategories:\n  - 后端\ndate: 2019-12-09 10:40:05\n---\n\n\n说到后端开发环境，最有名的莫过于LAMP和LNMP，最近由于node.js的强势崛起，越来越多的后端开发也开始试水node.js了。我最近也因为各种原因，前前后后总够构建了好几台node.js + nginx + mongodb的Linux服务器。\n\n首先关于Linux服务器，比起CentOS来说，我更加喜欢ubuntu一点。所以无论是阿里云还是一些海外的vps服务器上，我也倾向选用ubuntu服务器，本贴也是基于ubuntu服务器里说明的。\n\n## 1.开始前的一些准备\n\n首先还是需要刷新一下ubuntu的包索引并安装build-essential和libssl-dev这2个包以及curl这个工具。\n\n```sh\nsudo apt-get update\nsudo apt-get install build-essential libssl-dev\nsudo apt-get isntall curl\n```\n\n## 2.安装node.js\n\n关于安装node.js这一点，我不是很推荐使用apt-get 来安装node.js的环境。主要是因为node.js和io.js合并以后，版本迭代速度相当频繁(主要还是因为更多ES6的特性得到了支持）。今后很有可能会有在一台服务器上使用不同版本的node.js的需求。\n\n这里推荐一个管理不同版本node.js的工具：nvm，官网: [https://github.com/creationix/nvm](https://github.com/creationix/nvm)  。安装nvm，如果前面你安装了curl的话可以\n\n```sh\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash\n```\n如果没有按照curl的话，也可以使用wget来进行安装\n\n```sh\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash\n```\n\n然后nvm就会自动安装到home目录下面的.nvm目录里，并会在.bashrc里自动添加nvm的环境变量。为了让环境变量生效，最简单的方法就是通过ssh或是telnet重新连接你的服务器。\n\n安装完nvm后，就可以通过nvm来安装指定版本的node.js了。\n\n```sh\n# 列出可以安装的node版本号\nnvm ls-remote\n\n# 安装指定版本的node (当前最新版本为v5.7.1, LTS版是v4.3.2)\nnvm install v4.3.2\n```\n\n## 3.安装nginx\n\n由于ubuntu源（尤其是阿里云的源）上的nginx经常不是最新的，如果需要安装最新版本nginx的时候需要手动添加nginx的源。\n\n```sh\n# 添加nginx的mainline仓库\ncd /tmp/ && wget http://nginx.org/keys/nginx_signing.key\nsudo apt-key add nginx_signing.key\n\n# 编辑/etc/apt/sources.list.d/nginx.list 添加下面2行内容，井号不需要\n# deb http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx\n# deb-src http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx\nsudo vi  /etc/apt/sources.list.d/nginx.list\n\n# 更新源，并安装nginx\nsudo apt-get update && sudo apt-get install nginx\n```\n\n在编辑/etc/apt/sources.list.d/nginx.list的时候需要注意，“ubuntu代号”需要根据ubuntu服务器的版本不同手动调整的，比如14.04是trusty。通过下面的命令可以获取ubuntu的代号。\n```sh\nlsb_release -cs\n```\n\n## 4.安装mongodb\n\n同样和nginx有同样的问题，要安装最新3.2版本的mongodb也需要手动添加ubuntu的源。\n\n```sh\n# 导入mongodb的public key\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927\n\n# 生成mongodb的源list\necho \"deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list\n\n# 更新源\nsudo apt-get update\n\n# 安装最新版本的mongodb\nsudo apt-get install -y mongodb-org\n```\n\n以上一台node.js + nginx + mongodb的ubuntu服务器就完成了。\n\n","slug":"hot-to-install-nodejs-nginx-mongodb-on-ubuntu","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjr000a4goihf3c0c7k","content":"<p>说到后端开发环境，最有名的莫过于LAMP和LNMP，最近由于node.js的强势崛起，越来越多的后端开发也开始试水node.js了。我最近也因为各种原因，前前后后总够构建了好几台node.js + nginx + mongodb的Linux服务器。</p>\n<p>首先关于Linux服务器，比起CentOS来说，我更加喜欢ubuntu一点。所以无论是阿里云还是一些海外的vps服务器上，我也倾向选用ubuntu服务器，本贴也是基于ubuntu服务器里说明的。</p>\n<h2 id=\"1-开始前的一些准备\"><a href=\"#1-开始前的一些准备\" class=\"headerlink\" title=\"1.开始前的一些准备\"></a>1.开始前的一些准备</h2><p>首先还是需要刷新一下ubuntu的包索引并安装build-essential和libssl-dev这2个包以及curl这个工具。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install build-essential libssl-dev</span><br><span class=\"line\">sudo apt-get isntall curl</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装node-js\"><a href=\"#2-安装node-js\" class=\"headerlink\" title=\"2.安装node.js\"></a>2.安装node.js</h2><p>关于安装node.js这一点，我不是很推荐使用apt-get 来安装node.js的环境。主要是因为node.js和io.js合并以后，版本迭代速度相当频繁(主要还是因为更多ES6的特性得到了支持）。今后很有可能会有在一台服务器上使用不同版本的node.js的需求。</p>\n<p>这里推荐一个管理不同版本node.js的工具：nvm，官网: <a href=\"https://github.com/creationix/nvm\">https://github.com/creationix/nvm</a>  。安装nvm，如果前面你安装了curl的话可以</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>如果没有按照curl的话，也可以使用wget来进行安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n\n<p>然后nvm就会自动安装到home目录下面的.nvm目录里，并会在.bashrc里自动添加nvm的环境变量。为了让环境变量生效，最简单的方法就是通过ssh或是telnet重新连接你的服务器。</p>\n<p>安装完nvm后，就可以通过nvm来安装指定版本的node.js了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出可以安装的node版本号</span></span><br><span class=\"line\">nvm ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装指定版本的node (当前最新版本为v5.7.1, LTS版是v4.3.2)</span></span><br><span class=\"line\">nvm install v4.3.2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-安装nginx\"><a href=\"#3-安装nginx\" class=\"headerlink\" title=\"3.安装nginx\"></a>3.安装nginx</h2><p>由于ubuntu源（尤其是阿里云的源）上的nginx经常不是最新的，如果需要安装最新版本nginx的时候需要手动添加nginx的源。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加nginx的mainline仓库</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/ &amp;&amp; wget http://nginx.org/keys/nginx_signing.key</span><br><span class=\"line\">sudo apt-key add nginx_signing.key</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑/etc/apt/sources.list.d/nginx.list 添加下面2行内容，井号不需要</span></span><br><span class=\"line\"><span class=\"comment\"># deb http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx</span></span><br><span class=\"line\"><span class=\"comment\"># deb-src http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx</span></span><br><span class=\"line\">sudo vi  /etc/apt/sources.list.d/nginx.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新源，并安装nginx</span></span><br><span class=\"line\">sudo apt-get update &amp;&amp; sudo apt-get install nginx</span><br></pre></td></tr></table></figure>\n\n<p>在编辑/etc/apt/sources.list.d/nginx.list的时候需要注意，“ubuntu代号”需要根据ubuntu服务器的版本不同手动调整的，比如14.04是trusty。通过下面的命令可以获取ubuntu的代号。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsb_release -cs</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-安装mongodb\"><a href=\"#4-安装mongodb\" class=\"headerlink\" title=\"4.安装mongodb\"></a>4.安装mongodb</h2><p>同样和nginx有同样的问题，要安装最新3.2版本的mongodb也需要手动添加ubuntu的源。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入mongodb的public key</span></span><br><span class=\"line\">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成mongodb的源list</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.2 multiverse&quot;</span> | sudo <span class=\"built_in\">tee</span> /etc/apt/sources.list.d/mongodb-org-3.2.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新源</span></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装最新版本的mongodb</span></span><br><span class=\"line\">sudo apt-get install -y mongodb-org</span><br></pre></td></tr></table></figure>\n\n<p>以上一台node.js + nginx + mongodb的ubuntu服务器就完成了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>说到后端开发环境，最有名的莫过于LAMP和LNMP，最近由于node.js的强势崛起，越来越多的后端开发也开始试水node.js了。我最近也因为各种原因，前前后后总够构建了好几台node.js + nginx + mongodb的Linux服务器。</p>\n<p>首先关于Linux服务器，比起CentOS来说，我更加喜欢ubuntu一点。所以无论是阿里云还是一些海外的vps服务器上，我也倾向选用ubuntu服务器，本贴也是基于ubuntu服务器里说明的。</p>\n<h2 id=\"1-开始前的一些准备\"><a href=\"#1-开始前的一些准备\" class=\"headerlink\" title=\"1.开始前的一些准备\"></a>1.开始前的一些准备</h2><p>首先还是需要刷新一下ubuntu的包索引并安装build-essential和libssl-dev这2个包以及curl这个工具。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install build-essential libssl-dev</span><br><span class=\"line\">sudo apt-get isntall curl</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装node-js\"><a href=\"#2-安装node-js\" class=\"headerlink\" title=\"2.安装node.js\"></a>2.安装node.js</h2><p>关于安装node.js这一点，我不是很推荐使用apt-get 来安装node.js的环境。主要是因为node.js和io.js合并以后，版本迭代速度相当频繁(主要还是因为更多ES6的特性得到了支持）。今后很有可能会有在一台服务器上使用不同版本的node.js的需求。</p>\n<p>这里推荐一个管理不同版本node.js的工具：nvm，官网: <a href=\"https://github.com/creationix/nvm\">https://github.com/creationix/nvm</a>  。安装nvm，如果前面你安装了curl的话可以</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>如果没有按照curl的话，也可以使用wget来进行安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n\n<p>然后nvm就会自动安装到home目录下面的.nvm目录里，并会在.bashrc里自动添加nvm的环境变量。为了让环境变量生效，最简单的方法就是通过ssh或是telnet重新连接你的服务器。</p>\n<p>安装完nvm后，就可以通过nvm来安装指定版本的node.js了。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出可以安装的node版本号</span></span><br><span class=\"line\">nvm ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装指定版本的node (当前最新版本为v5.7.1, LTS版是v4.3.2)</span></span><br><span class=\"line\">nvm install v4.3.2</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-安装nginx\"><a href=\"#3-安装nginx\" class=\"headerlink\" title=\"3.安装nginx\"></a>3.安装nginx</h2><p>由于ubuntu源（尤其是阿里云的源）上的nginx经常不是最新的，如果需要安装最新版本nginx的时候需要手动添加nginx的源。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加nginx的mainline仓库</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/ &amp;&amp; wget http://nginx.org/keys/nginx_signing.key</span><br><span class=\"line\">sudo apt-key add nginx_signing.key</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑/etc/apt/sources.list.d/nginx.list 添加下面2行内容，井号不需要</span></span><br><span class=\"line\"><span class=\"comment\"># deb http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx</span></span><br><span class=\"line\"><span class=\"comment\"># deb-src http://nginx.org/packages/mainline/ubuntu/ ubuntu代号 nginx</span></span><br><span class=\"line\">sudo vi  /etc/apt/sources.list.d/nginx.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新源，并安装nginx</span></span><br><span class=\"line\">sudo apt-get update &amp;&amp; sudo apt-get install nginx</span><br></pre></td></tr></table></figure>\n\n<p>在编辑/etc/apt/sources.list.d/nginx.list的时候需要注意，“ubuntu代号”需要根据ubuntu服务器的版本不同手动调整的，比如14.04是trusty。通过下面的命令可以获取ubuntu的代号。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsb_release -cs</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-安装mongodb\"><a href=\"#4-安装mongodb\" class=\"headerlink\" title=\"4.安装mongodb\"></a>4.安装mongodb</h2><p>同样和nginx有同样的问题，要安装最新3.2版本的mongodb也需要手动添加ubuntu的源。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入mongodb的public key</span></span><br><span class=\"line\">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成mongodb的源list</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.2 multiverse&quot;</span> | sudo <span class=\"built_in\">tee</span> /etc/apt/sources.list.d/mongodb-org-3.2.list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新源</span></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装最新版本的mongodb</span></span><br><span class=\"line\">sudo apt-get install -y mongodb-org</span><br></pre></td></tr></table></figure>\n\n<p>以上一台node.js + nginx + mongodb的ubuntu服务器就完成了。</p>\n"},{"title":"阿里云Kubernetes上线踩坑记","date":"2020-04-01T01:47:38.000Z","_content":"\n```\nUpdate:\n2020-04-08 增加istio-ingressgateway高可用的设置\n```\n\n最近公司因为项目需要，在阿里云上部署了一个Kubernetes集群。虽然阿里云的文档说的还算细致，但是还是有些没有明确说明的细节。\n\n# 1. 购买篇\n\n申请项目预算的时候，只考虑到Worker节点，1个SLB节点以及域名和证书的预算。但是实际购买的时候发现还有许多额外的开销。\n\n## 1.1 SNAT\n\n这个和EIP一并购买，可以方便通过公网使用kubectl访问集群。关于SNAT网关至今不是很明白需要购买这个服务的意义何在，只是为了一个EIP来访问集群吗？\n\n## 1.2 Ingress\n\n这个选上了后，阿里云会给你买个SLB而且还是带公网访问的，如果你后期考虑使用Istio的话，建议你集群创建后，直接停止这个SLB，以免产生额外的费用。\n\n## 1.3 日志服务\n\n通过阿里云的日志服务来收集应用的的日志，挺好用的。但是另外收费，如果有能力的自建日志服务的可不购买。\n\n# 2. Istio\n\n阿里云的Kubernetes集群完美集成了Istio，根据向导就能很简单的部署成功。\n\n## 2.1 额外的SLB\n\nIstio的Gateway 需要绑定一个新的SLB，和Ingress的SLB不能是同一个，又是一笔额外的开销\n\n## 2.2 集群外访问\n\n这个在阿里云的Istio FAQ中有提到，按照指导很容易解决\n\n## 2.2 SLB的443监听\n\n为了方便443端口的证书绑定，我们直接删除了SLB上原有的443监听(TCP协议), 重新建了一个443监听(HTTPS协议)，指向和80端口同样的虚拟服务器组。但是设置健康检查时一直出错，经过排查发现SLB健康检查发送的请求协议是HTTP 1.0的，Istio的envoy直接反悔了`426(Upgrade Required)`这个状态码，所以我们无奈只能把健康检查的检查返回状态改为http_4xx，这样就能通过SLB的健康检查了。\n\n## 2.3 istio-ingressgateway的高可用\n\n`istio-ingressgateway`要达成高可用，只需要增加通过伸缩POD就可以实现，于`istio-ingressgateway`对应的SLB中的虚拟服务器组也会自动增加，完全不需要进行额外的手动设定。\n\n由于`istio-ingressgateway`中挂载了HPA`HorizontalPodAutoscaler`(简称HPA)，通常三节点的集群中最小POD数只有1台，在3节点的集群中，要实现高可用，需要手动修改HPA，增加最小POD数。\n\n---\n\n基本上现在遇到了这些坑，再有在总结吧。\n","source":"_posts/阿里云Kubernetes上线踩坑记.md","raw":"---\ntitle: 阿里云Kubernetes上线踩坑记\ndate: 2020-04-01 09:47:38\ntags:\n - Aliyun\n - Kubernetes\ncategories:\n  - 后端\n  - Cloud\n---\n\n```\nUpdate:\n2020-04-08 增加istio-ingressgateway高可用的设置\n```\n\n最近公司因为项目需要，在阿里云上部署了一个Kubernetes集群。虽然阿里云的文档说的还算细致，但是还是有些没有明确说明的细节。\n\n# 1. 购买篇\n\n申请项目预算的时候，只考虑到Worker节点，1个SLB节点以及域名和证书的预算。但是实际购买的时候发现还有许多额外的开销。\n\n## 1.1 SNAT\n\n这个和EIP一并购买，可以方便通过公网使用kubectl访问集群。关于SNAT网关至今不是很明白需要购买这个服务的意义何在，只是为了一个EIP来访问集群吗？\n\n## 1.2 Ingress\n\n这个选上了后，阿里云会给你买个SLB而且还是带公网访问的，如果你后期考虑使用Istio的话，建议你集群创建后，直接停止这个SLB，以免产生额外的费用。\n\n## 1.3 日志服务\n\n通过阿里云的日志服务来收集应用的的日志，挺好用的。但是另外收费，如果有能力的自建日志服务的可不购买。\n\n# 2. Istio\n\n阿里云的Kubernetes集群完美集成了Istio，根据向导就能很简单的部署成功。\n\n## 2.1 额外的SLB\n\nIstio的Gateway 需要绑定一个新的SLB，和Ingress的SLB不能是同一个，又是一笔额外的开销\n\n## 2.2 集群外访问\n\n这个在阿里云的Istio FAQ中有提到，按照指导很容易解决\n\n## 2.2 SLB的443监听\n\n为了方便443端口的证书绑定，我们直接删除了SLB上原有的443监听(TCP协议), 重新建了一个443监听(HTTPS协议)，指向和80端口同样的虚拟服务器组。但是设置健康检查时一直出错，经过排查发现SLB健康检查发送的请求协议是HTTP 1.0的，Istio的envoy直接反悔了`426(Upgrade Required)`这个状态码，所以我们无奈只能把健康检查的检查返回状态改为http_4xx，这样就能通过SLB的健康检查了。\n\n## 2.3 istio-ingressgateway的高可用\n\n`istio-ingressgateway`要达成高可用，只需要增加通过伸缩POD就可以实现，于`istio-ingressgateway`对应的SLB中的虚拟服务器组也会自动增加，完全不需要进行额外的手动设定。\n\n由于`istio-ingressgateway`中挂载了HPA`HorizontalPodAutoscaler`(简称HPA)，通常三节点的集群中最小POD数只有1台，在3节点的集群中，要实现高可用，需要手动修改HPA，增加最小POD数。\n\n---\n\n基本上现在遇到了这些坑，再有在总结吧。\n","slug":"阿里云Kubernetes上线踩坑记","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjr000b4goi8fzg64kj","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Update:</span><br><span class=\"line\">2020-04-08 增加istio-ingressgateway高可用的设置</span><br></pre></td></tr></table></figure>\n\n<p>最近公司因为项目需要，在阿里云上部署了一个Kubernetes集群。虽然阿里云的文档说的还算细致，但是还是有些没有明确说明的细节。</p>\n<h1 id=\"1-购买篇\"><a href=\"#1-购买篇\" class=\"headerlink\" title=\"1. 购买篇\"></a>1. 购买篇</h1><p>申请项目预算的时候，只考虑到Worker节点，1个SLB节点以及域名和证书的预算。但是实际购买的时候发现还有许多额外的开销。</p>\n<h2 id=\"1-1-SNAT\"><a href=\"#1-1-SNAT\" class=\"headerlink\" title=\"1.1 SNAT\"></a>1.1 SNAT</h2><p>这个和EIP一并购买，可以方便通过公网使用kubectl访问集群。关于SNAT网关至今不是很明白需要购买这个服务的意义何在，只是为了一个EIP来访问集群吗？</p>\n<h2 id=\"1-2-Ingress\"><a href=\"#1-2-Ingress\" class=\"headerlink\" title=\"1.2 Ingress\"></a>1.2 Ingress</h2><p>这个选上了后，阿里云会给你买个SLB而且还是带公网访问的，如果你后期考虑使用Istio的话，建议你集群创建后，直接停止这个SLB，以免产生额外的费用。</p>\n<h2 id=\"1-3-日志服务\"><a href=\"#1-3-日志服务\" class=\"headerlink\" title=\"1.3 日志服务\"></a>1.3 日志服务</h2><p>通过阿里云的日志服务来收集应用的的日志，挺好用的。但是另外收费，如果有能力的自建日志服务的可不购买。</p>\n<h1 id=\"2-Istio\"><a href=\"#2-Istio\" class=\"headerlink\" title=\"2. Istio\"></a>2. Istio</h1><p>阿里云的Kubernetes集群完美集成了Istio，根据向导就能很简单的部署成功。</p>\n<h2 id=\"2-1-额外的SLB\"><a href=\"#2-1-额外的SLB\" class=\"headerlink\" title=\"2.1 额外的SLB\"></a>2.1 额外的SLB</h2><p>Istio的Gateway 需要绑定一个新的SLB，和Ingress的SLB不能是同一个，又是一笔额外的开销</p>\n<h2 id=\"2-2-集群外访问\"><a href=\"#2-2-集群外访问\" class=\"headerlink\" title=\"2.2 集群外访问\"></a>2.2 集群外访问</h2><p>这个在阿里云的Istio FAQ中有提到，按照指导很容易解决</p>\n<h2 id=\"2-2-SLB的443监听\"><a href=\"#2-2-SLB的443监听\" class=\"headerlink\" title=\"2.2 SLB的443监听\"></a>2.2 SLB的443监听</h2><p>为了方便443端口的证书绑定，我们直接删除了SLB上原有的443监听(TCP协议), 重新建了一个443监听(HTTPS协议)，指向和80端口同样的虚拟服务器组。但是设置健康检查时一直出错，经过排查发现SLB健康检查发送的请求协议是HTTP 1.0的，Istio的envoy直接反悔了<code>426(Upgrade Required)</code>这个状态码，所以我们无奈只能把健康检查的检查返回状态改为http_4xx，这样就能通过SLB的健康检查了。</p>\n<h2 id=\"2-3-istio-ingressgateway的高可用\"><a href=\"#2-3-istio-ingressgateway的高可用\" class=\"headerlink\" title=\"2.3 istio-ingressgateway的高可用\"></a>2.3 istio-ingressgateway的高可用</h2><p><code>istio-ingressgateway</code>要达成高可用，只需要增加通过伸缩POD就可以实现，于<code>istio-ingressgateway</code>对应的SLB中的虚拟服务器组也会自动增加，完全不需要进行额外的手动设定。</p>\n<p>由于<code>istio-ingressgateway</code>中挂载了HPA<code>HorizontalPodAutoscaler</code>(简称HPA)，通常三节点的集群中最小POD数只有1台，在3节点的集群中，要实现高可用，需要手动修改HPA，增加最小POD数。</p>\n<hr>\n<p>基本上现在遇到了这些坑，再有在总结吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Update:</span><br><span class=\"line\">2020-04-08 增加istio-ingressgateway高可用的设置</span><br></pre></td></tr></table></figure>\n\n<p>最近公司因为项目需要，在阿里云上部署了一个Kubernetes集群。虽然阿里云的文档说的还算细致，但是还是有些没有明确说明的细节。</p>\n<h1 id=\"1-购买篇\"><a href=\"#1-购买篇\" class=\"headerlink\" title=\"1. 购买篇\"></a>1. 购买篇</h1><p>申请项目预算的时候，只考虑到Worker节点，1个SLB节点以及域名和证书的预算。但是实际购买的时候发现还有许多额外的开销。</p>\n<h2 id=\"1-1-SNAT\"><a href=\"#1-1-SNAT\" class=\"headerlink\" title=\"1.1 SNAT\"></a>1.1 SNAT</h2><p>这个和EIP一并购买，可以方便通过公网使用kubectl访问集群。关于SNAT网关至今不是很明白需要购买这个服务的意义何在，只是为了一个EIP来访问集群吗？</p>\n<h2 id=\"1-2-Ingress\"><a href=\"#1-2-Ingress\" class=\"headerlink\" title=\"1.2 Ingress\"></a>1.2 Ingress</h2><p>这个选上了后，阿里云会给你买个SLB而且还是带公网访问的，如果你后期考虑使用Istio的话，建议你集群创建后，直接停止这个SLB，以免产生额外的费用。</p>\n<h2 id=\"1-3-日志服务\"><a href=\"#1-3-日志服务\" class=\"headerlink\" title=\"1.3 日志服务\"></a>1.3 日志服务</h2><p>通过阿里云的日志服务来收集应用的的日志，挺好用的。但是另外收费，如果有能力的自建日志服务的可不购买。</p>\n<h1 id=\"2-Istio\"><a href=\"#2-Istio\" class=\"headerlink\" title=\"2. Istio\"></a>2. Istio</h1><p>阿里云的Kubernetes集群完美集成了Istio，根据向导就能很简单的部署成功。</p>\n<h2 id=\"2-1-额外的SLB\"><a href=\"#2-1-额外的SLB\" class=\"headerlink\" title=\"2.1 额外的SLB\"></a>2.1 额外的SLB</h2><p>Istio的Gateway 需要绑定一个新的SLB，和Ingress的SLB不能是同一个，又是一笔额外的开销</p>\n<h2 id=\"2-2-集群外访问\"><a href=\"#2-2-集群外访问\" class=\"headerlink\" title=\"2.2 集群外访问\"></a>2.2 集群外访问</h2><p>这个在阿里云的Istio FAQ中有提到，按照指导很容易解决</p>\n<h2 id=\"2-2-SLB的443监听\"><a href=\"#2-2-SLB的443监听\" class=\"headerlink\" title=\"2.2 SLB的443监听\"></a>2.2 SLB的443监听</h2><p>为了方便443端口的证书绑定，我们直接删除了SLB上原有的443监听(TCP协议), 重新建了一个443监听(HTTPS协议)，指向和80端口同样的虚拟服务器组。但是设置健康检查时一直出错，经过排查发现SLB健康检查发送的请求协议是HTTP 1.0的，Istio的envoy直接反悔了<code>426(Upgrade Required)</code>这个状态码，所以我们无奈只能把健康检查的检查返回状态改为http_4xx，这样就能通过SLB的健康检查了。</p>\n<h2 id=\"2-3-istio-ingressgateway的高可用\"><a href=\"#2-3-istio-ingressgateway的高可用\" class=\"headerlink\" title=\"2.3 istio-ingressgateway的高可用\"></a>2.3 istio-ingressgateway的高可用</h2><p><code>istio-ingressgateway</code>要达成高可用，只需要增加通过伸缩POD就可以实现，于<code>istio-ingressgateway</code>对应的SLB中的虚拟服务器组也会自动增加，完全不需要进行额外的手动设定。</p>\n<p>由于<code>istio-ingressgateway</code>中挂载了HPA<code>HorizontalPodAutoscaler</code>(简称HPA)，通常三节点的集群中最小POD数只有1台，在3节点的集群中，要实现高可用，需要手动修改HPA，增加最小POD数。</p>\n<hr>\n<p>基本上现在遇到了这些坑，再有在总结吧。</p>\n"},{"title":"重学Java (一) 泛型","date":"2021-03-15T08:01:46.000Z","_content":"\n## 1. 前言\n\n泛型编程自从 Java 5.0 中引入后已经超过15个年头了。对于现在的 Java 码农来说熟练使用泛型编程已经是家常便饭的事情了。所以本文就在不对泛型的基础使用在做说明了。 如果你还不会使用泛型的话，可以参考下面两个链接\n\n- [Java 泛型详解](https://blog.csdn.net/qq_24084925/article/details/68491132)\n- [The Java™ Tutorials (Lesson: Generics)](https://docs.oracle.com/javase/tutorial/java/generics/index.html)\n\n这篇文章就简答聊一下，我实际在开发工作中很少用的到泛型方法这个知识点，以及在实际项目中有哪些东西会使用到泛型。\n\n## 2. 泛型方法\n\n在阅读代码的时候我们经常会看到下面这样的方法 (这段代码摘自 `java.util.AbstractCollection`)\n\n```java\n public <T> T[] toArray(T[] a) {\n    // Estimate size of array; be prepared to see more or fewer elements\n    int size = size();\n    T[] r = a.length >= size ? a :\n              (T[])java.lang.reflect.Array\n              .newInstance(a.getClass().getComponentType(), size);\n    Iterator<E> it = iterator();\n\n    for (int i = 0; i < r.length; i++) {\n        if (! it.hasNext()) { // fewer elements than expected\n            if (a == r) {\n                r[i] = null; // null-terminate\n            } else if (a.length < i) {\n                return Arrays.copyOf(r, i);\n            } else {\n                System.arraycopy(r, 0, a, 0, i);\n                if (a.length > i) {\n                    a[i] = null;\n                }\n            }\n            return a;\n        }\n        r[i] = (T)it.next();\n    }\n    // more elements than expected\n    return it.hasNext() ? finishToArray(r, it) : r;\n}\n```\n\n那么 `pulic` 关键字后面的那个 `<T>` 就是用来标记这个方法是一个泛型方法。 那什么是泛型方法呢。\n\n官方的解释是这样的\n\n```\nGeneric methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter's scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.\n```\n\n通俗点来将就是将一个方法泛型化，让一个普通的类的某一个方法具有泛型功能。 如果在一个泛型类中增加一个泛型方法，那这个泛型方法就可以有一套独立于这个类的泛型类型。\n\n通过一个简单的例子, 我们来看看\n\n```java\n/**\n * GenericClass 这个泛型类是一个简单的套皮的 HashMap\n */\npublic class GenericClass<K, V> {\n\n    private Map<K, V> map = new HashMap<>();\n\n    public V put(K key, V value) {\n       return map.put(key, value);\n    }\n\n    public V get(K key) {\n        return map.get(key);\n    }\n\n    // 泛型方法 genericMethod 可以接受一个全新的、作用域只限本函数的泛型类型T\n    public <T> T genericMethod(T t) {\n        return t;\n    }\n\n}\n```\n\n实际使用起来\n\n```java\nGenericClass<String, Integer> map = new GenericClass<>();\n// put 和 get 方法的参数必须使用定义时指定的 String 和 Integer\nSystem.out.println(map.put(\"One\", 1));\nSystem.out.println(map.get(\"One\"));\n// 泛型方法 genericMethod 就可以接受一个 String 和 Integer 以外的类型\nSystem.out.println(map.genericMethod(new Double(1.0)).getClass());\n```\n\n我们再来看看 JDK 中使用到泛型方法的例子。我们最常使用的泛型容器 `ArrayList` 中有个 `toArray` 方法。JDK 在它的实现中就提供了两个版本，其中一个就是泛型方法的版本\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable \n{\n    // 这是一个普通版本，返回一个Object的数组\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n    \n    // 这是一个泛型方法的版本，将容器里存储的元素输出到 T[] 数组中。 其中 T 必须是 E 的父类，否则 System.arraycopy 会抛出 ArrayStoreException 异常      \n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a's runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n}\n```\n\n泛型方法总体上来说就是可以给与现有的方法实现上，增加一个更加灵活的实现可能。\n\n## 3. 实战应用\n\n在实际的项目中，对于泛型的使用，除了像倾倒垃圾一样往泛型容易里塞各种 java bean 和其他泛型对象。还能怎么使用泛型呢？\n\n我们在实际的一些项目中，会对数据库中的一些表(多数时候是全部)先实现 CRUD (Create, Read, Update, Delete)的操作，并从这些操作中延伸出一些简单的 REST 风格的 WebAPI 接口，然后才会根据实际业务需要实现一些更复杂的业务接口。 \n\n大体上会是下面这个样子。 \n\n```java\n\n// 这是一个简单的 Entity 对象\n// 通常现在的 Java 应用都会使用到 Lombok 和 Spring Boot\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@ToString\n@Entity\n@Table(name = \"user\")\npublic class User {\n    @Id\n    private Long id;\n    private String username;\n    private String password;\n}\n\n// 然后这个是 DAO 接口继承自 spring-data 的 JpaRepository\npublic interface UserDao extends JpaRepository<User, Long> {\n}\n\n// 在来是一个访问 User 资源的 Service 和他的实现\npublic interface UserService {\n    List<User> findAll();\n    Optional<User> findById(Long id);\n    User save (User user)\n    void deleteById(Long id);\n}\n\n@Service\npublic class UserSerivceImpl implements UserService {\n    private UserDao userDao;\n    public UserServiceImpl(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    @Override\n    public List<User> findAll() {\n        return this.dao.findAll();\n    }\n\n    @Override\n    public Optional<User> findById(Long id) {\n        return this.dao.findById(id);\n    }\n\n    @Override\n    public User save(User user) {\n        return this.dao.save(user);\n    }\n\n    @Override\n    public void deleteById(Long id) {\n        this.dao.deleteById(id);\n    }\n}\n\n// 最后就是 WebAPI 的接口了\n@RestController\n@RequestMapping(\"/user/\")\npublic class UserController{\n    private UserService userService;\n    public UserController(userService userService) {\n        this.userService = userService;\n    }\n\n    @GetMapping\n    @ResponseBody\n    public List<User> fetch() {\n        return this.userService.findAll();\n    }\n\n    @GetMapping(\"{id}\")\n    @ResponseBody\n    public User get(@PathVariable(\"id\") Long id) {\n        // 由于是示例这里就不考虑没有数据的情况了\n        return this.userService.findById(id).get();\n    }\n\n    @PostMapping\n    @ResponseBody\n    public User create(@RequestBody User user) {\n        return this.userService.save(user);\n    }\n\n    @PutMapping(\"{id}\")\n    @ResponseBody\n    public User update(@RequestBody User user) {\n        return this.userService.save(user);\n    }\n\n    @DeleteMapping(\"{id}\")\n    @ResponseBody\n    public User delete(@PathVariable(\"id\") Long id) {\n        User user = this.userService.findById(id);\n        this.userService.deleteById(id);\n        return user;\n    }\n}\n```\n\n大致一个表的一套相关接口就是这个样子的。如果你的数据库中有大量表的话，而且每个表都需要提供 REST 风格的 WebAPI 接口的话，那么这将是一个相当枯燥的而又及其容易出错的工作。\n\n为了不让这项枯燥而又容易犯错的工作占去我们宝贵的私人时间，我们可以通过泛型和继承的技巧来重构从 Service 层到 Controller 的这段代码(感谢 spring-data 提供了 `JpaRepository`, 让我们不至于从 DAO 层重构)\n\n## 3.1 Service 层的重构\n\n首先是 Service 接口的重构，我们 Service 层接口就是定义了一组 CRUD 的操作，我们可以将这组 CRUD 操作抽象到一个父接口，然后所有 Service 层的接口都将继承自这个父接口。而接口中出现的 Entity 和主键的类型(上例中 User 的主键 id 的类型是 Long)就可以用泛型来展现。\n\n```java\n// 这里泛型表示 E 来指代 Entity, ID 用来指代 Entity 主键的类型\npublic interface ICrudService<E, ID> {\n    List<E> findAll();\n    Optional<E> findById(ID id);\n    E save(E e);\n    void deleteById(ID id);\n}\n\n// 然后 Service 层的接口，就可以简化成这样\npublic interface UserService extends ICrudService<User, Long> {\n}\n```\n\n同样 Service 层的实现也可以使用相似的方法具体实现可以抽象到一个基类中。\n\n```java\n// 相比 ICrudService 这里有多了一个泛型 T 来代表 Entity 对应的 DAO, 我们的每一个 DAO 都继承自\n// spring-data 的 JpaRepository 所以，这里可以使用到泛型的边界\npublic abstract class AbstractCrudService<T extends JpaRepository<E, ID>, E, ID> {\n    private T dao;\n    public AbstractCrudService(T dao) {\n        this.dao = dao;\n    }\n\n    public List<E> findAll() {\n        return this.dao.findAll();\n    }\n\n    public Optional<E> findById(ID id) {\n        return this.dao.findById(id);\n    }\n\n    public E save(E e) {\n        return this.dao.save(e);\n    }\n\n    public void deleteById(ID id) {\n        this.dao.deleteById(id);\n    }\n}\n\n// 那 Service 的实现类可以简化成这样\n@Service\npublic class UserServiceImpl extends AbstractCrudService<UserDao, User, Long> implements UserService {\n    public UserServiceImpl(UserDao dao) {\n        supper(dao);\n    }\n}\n```\n\n同样我们可以通过相同的方法来对 Controller 层进行重构\n\n```java\n// Controller 层的基类\npublic abstract class AbstractCrudController<T extends ICrudService<E, ID>, E, ID> {\n    private T service;\n    public AbstractCrudController(T service) {\n        this.service = service;\n    }\n\n    @GetMapping\n    @ResponseBody\n    public List<E> fetch() {\n        return this.service.findAll();\n    }\n\n    @GetMapping(\"{id}\")\n    @ResponseBody\n    public E get(@PathVariable(\"id\") ID id) {\n        // 由于是示例这里就不考虑没有数据的情况了\n        return this.service.findById(id).get();\n    }\n\n    @PostMapping\n    @ResponseBody\n    public E create(@RequestBody E e) {\n        return this.service.save(e);\n    }\n\n    @PutMapping(\"{id}\")\n    @ResponseBody\n    public E update(@RequestBody E e) {\n        return this.service.save(e);\n    }\n\n    @DeleteMapping(\"{id}\")\n    @ResponseBody\n    public E delete(@PathVariable(\"id\") ID id) {\n        E e = this.service.findById(id).get();\n        this.service.deleteById(id);\n        return e;\n    }\n}\n\n// 具体的 WebAPI\n@RestController\n@RequestMapping(\"/user/\")\npublic class UserController extends AbstractCrudController<UserService, User, Long> {\n    public UserController(UserService service) {\n        super(service);\n    }\n}\n```\n\n经过重构可以消减掉 Servcie 和 Controller 中的大量重复代码，使代码更容易维护了。\n\n## 4. 结尾\n\n关于泛型就简单的说这些了，泛型作为 Java 日常开发中一个常用的知识点，其实还有很多知识点可以供我们挖掘，奈何本人才疏学浅，这么多年工作下来，只积累出来这么点内容。\n\n文末放上示例代码的代码库: \n\n- [GitHub入口](https://github.com/hashmaparraylist/re-study-java)\n- [gitee入口](https://gitee.com/hashmaparraylist/re-study-java)\n\n","source":"_posts/重学Java-一-泛型.md","raw":"---\ntitle: 重学Java (一) 泛型\ndate: 2021-03-15 16:01:46\ntags: \n    - java\n    - generic\ncategories:\n    - 后端\n---\n\n## 1. 前言\n\n泛型编程自从 Java 5.0 中引入后已经超过15个年头了。对于现在的 Java 码农来说熟练使用泛型编程已经是家常便饭的事情了。所以本文就在不对泛型的基础使用在做说明了。 如果你还不会使用泛型的话，可以参考下面两个链接\n\n- [Java 泛型详解](https://blog.csdn.net/qq_24084925/article/details/68491132)\n- [The Java™ Tutorials (Lesson: Generics)](https://docs.oracle.com/javase/tutorial/java/generics/index.html)\n\n这篇文章就简答聊一下，我实际在开发工作中很少用的到泛型方法这个知识点，以及在实际项目中有哪些东西会使用到泛型。\n\n## 2. 泛型方法\n\n在阅读代码的时候我们经常会看到下面这样的方法 (这段代码摘自 `java.util.AbstractCollection`)\n\n```java\n public <T> T[] toArray(T[] a) {\n    // Estimate size of array; be prepared to see more or fewer elements\n    int size = size();\n    T[] r = a.length >= size ? a :\n              (T[])java.lang.reflect.Array\n              .newInstance(a.getClass().getComponentType(), size);\n    Iterator<E> it = iterator();\n\n    for (int i = 0; i < r.length; i++) {\n        if (! it.hasNext()) { // fewer elements than expected\n            if (a == r) {\n                r[i] = null; // null-terminate\n            } else if (a.length < i) {\n                return Arrays.copyOf(r, i);\n            } else {\n                System.arraycopy(r, 0, a, 0, i);\n                if (a.length > i) {\n                    a[i] = null;\n                }\n            }\n            return a;\n        }\n        r[i] = (T)it.next();\n    }\n    // more elements than expected\n    return it.hasNext() ? finishToArray(r, it) : r;\n}\n```\n\n那么 `pulic` 关键字后面的那个 `<T>` 就是用来标记这个方法是一个泛型方法。 那什么是泛型方法呢。\n\n官方的解释是这样的\n\n```\nGeneric methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter's scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.\n```\n\n通俗点来将就是将一个方法泛型化，让一个普通的类的某一个方法具有泛型功能。 如果在一个泛型类中增加一个泛型方法，那这个泛型方法就可以有一套独立于这个类的泛型类型。\n\n通过一个简单的例子, 我们来看看\n\n```java\n/**\n * GenericClass 这个泛型类是一个简单的套皮的 HashMap\n */\npublic class GenericClass<K, V> {\n\n    private Map<K, V> map = new HashMap<>();\n\n    public V put(K key, V value) {\n       return map.put(key, value);\n    }\n\n    public V get(K key) {\n        return map.get(key);\n    }\n\n    // 泛型方法 genericMethod 可以接受一个全新的、作用域只限本函数的泛型类型T\n    public <T> T genericMethod(T t) {\n        return t;\n    }\n\n}\n```\n\n实际使用起来\n\n```java\nGenericClass<String, Integer> map = new GenericClass<>();\n// put 和 get 方法的参数必须使用定义时指定的 String 和 Integer\nSystem.out.println(map.put(\"One\", 1));\nSystem.out.println(map.get(\"One\"));\n// 泛型方法 genericMethod 就可以接受一个 String 和 Integer 以外的类型\nSystem.out.println(map.genericMethod(new Double(1.0)).getClass());\n```\n\n我们再来看看 JDK 中使用到泛型方法的例子。我们最常使用的泛型容器 `ArrayList` 中有个 `toArray` 方法。JDK 在它的实现中就提供了两个版本，其中一个就是泛型方法的版本\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable \n{\n    // 这是一个普通版本，返回一个Object的数组\n    public Object[] toArray() {\n        return Arrays.copyOf(elementData, size);\n    }\n    \n    // 这是一个泛型方法的版本，将容器里存储的元素输出到 T[] 数组中。 其中 T 必须是 E 的父类，否则 System.arraycopy 会抛出 ArrayStoreException 异常      \n    public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a's runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }\n}\n```\n\n泛型方法总体上来说就是可以给与现有的方法实现上，增加一个更加灵活的实现可能。\n\n## 3. 实战应用\n\n在实际的项目中，对于泛型的使用，除了像倾倒垃圾一样往泛型容易里塞各种 java bean 和其他泛型对象。还能怎么使用泛型呢？\n\n我们在实际的一些项目中，会对数据库中的一些表(多数时候是全部)先实现 CRUD (Create, Read, Update, Delete)的操作，并从这些操作中延伸出一些简单的 REST 风格的 WebAPI 接口，然后才会根据实际业务需要实现一些更复杂的业务接口。 \n\n大体上会是下面这个样子。 \n\n```java\n\n// 这是一个简单的 Entity 对象\n// 通常现在的 Java 应用都会使用到 Lombok 和 Spring Boot\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@ToString\n@Entity\n@Table(name = \"user\")\npublic class User {\n    @Id\n    private Long id;\n    private String username;\n    private String password;\n}\n\n// 然后这个是 DAO 接口继承自 spring-data 的 JpaRepository\npublic interface UserDao extends JpaRepository<User, Long> {\n}\n\n// 在来是一个访问 User 资源的 Service 和他的实现\npublic interface UserService {\n    List<User> findAll();\n    Optional<User> findById(Long id);\n    User save (User user)\n    void deleteById(Long id);\n}\n\n@Service\npublic class UserSerivceImpl implements UserService {\n    private UserDao userDao;\n    public UserServiceImpl(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n    @Override\n    public List<User> findAll() {\n        return this.dao.findAll();\n    }\n\n    @Override\n    public Optional<User> findById(Long id) {\n        return this.dao.findById(id);\n    }\n\n    @Override\n    public User save(User user) {\n        return this.dao.save(user);\n    }\n\n    @Override\n    public void deleteById(Long id) {\n        this.dao.deleteById(id);\n    }\n}\n\n// 最后就是 WebAPI 的接口了\n@RestController\n@RequestMapping(\"/user/\")\npublic class UserController{\n    private UserService userService;\n    public UserController(userService userService) {\n        this.userService = userService;\n    }\n\n    @GetMapping\n    @ResponseBody\n    public List<User> fetch() {\n        return this.userService.findAll();\n    }\n\n    @GetMapping(\"{id}\")\n    @ResponseBody\n    public User get(@PathVariable(\"id\") Long id) {\n        // 由于是示例这里就不考虑没有数据的情况了\n        return this.userService.findById(id).get();\n    }\n\n    @PostMapping\n    @ResponseBody\n    public User create(@RequestBody User user) {\n        return this.userService.save(user);\n    }\n\n    @PutMapping(\"{id}\")\n    @ResponseBody\n    public User update(@RequestBody User user) {\n        return this.userService.save(user);\n    }\n\n    @DeleteMapping(\"{id}\")\n    @ResponseBody\n    public User delete(@PathVariable(\"id\") Long id) {\n        User user = this.userService.findById(id);\n        this.userService.deleteById(id);\n        return user;\n    }\n}\n```\n\n大致一个表的一套相关接口就是这个样子的。如果你的数据库中有大量表的话，而且每个表都需要提供 REST 风格的 WebAPI 接口的话，那么这将是一个相当枯燥的而又及其容易出错的工作。\n\n为了不让这项枯燥而又容易犯错的工作占去我们宝贵的私人时间，我们可以通过泛型和继承的技巧来重构从 Service 层到 Controller 的这段代码(感谢 spring-data 提供了 `JpaRepository`, 让我们不至于从 DAO 层重构)\n\n## 3.1 Service 层的重构\n\n首先是 Service 接口的重构，我们 Service 层接口就是定义了一组 CRUD 的操作，我们可以将这组 CRUD 操作抽象到一个父接口，然后所有 Service 层的接口都将继承自这个父接口。而接口中出现的 Entity 和主键的类型(上例中 User 的主键 id 的类型是 Long)就可以用泛型来展现。\n\n```java\n// 这里泛型表示 E 来指代 Entity, ID 用来指代 Entity 主键的类型\npublic interface ICrudService<E, ID> {\n    List<E> findAll();\n    Optional<E> findById(ID id);\n    E save(E e);\n    void deleteById(ID id);\n}\n\n// 然后 Service 层的接口，就可以简化成这样\npublic interface UserService extends ICrudService<User, Long> {\n}\n```\n\n同样 Service 层的实现也可以使用相似的方法具体实现可以抽象到一个基类中。\n\n```java\n// 相比 ICrudService 这里有多了一个泛型 T 来代表 Entity 对应的 DAO, 我们的每一个 DAO 都继承自\n// spring-data 的 JpaRepository 所以，这里可以使用到泛型的边界\npublic abstract class AbstractCrudService<T extends JpaRepository<E, ID>, E, ID> {\n    private T dao;\n    public AbstractCrudService(T dao) {\n        this.dao = dao;\n    }\n\n    public List<E> findAll() {\n        return this.dao.findAll();\n    }\n\n    public Optional<E> findById(ID id) {\n        return this.dao.findById(id);\n    }\n\n    public E save(E e) {\n        return this.dao.save(e);\n    }\n\n    public void deleteById(ID id) {\n        this.dao.deleteById(id);\n    }\n}\n\n// 那 Service 的实现类可以简化成这样\n@Service\npublic class UserServiceImpl extends AbstractCrudService<UserDao, User, Long> implements UserService {\n    public UserServiceImpl(UserDao dao) {\n        supper(dao);\n    }\n}\n```\n\n同样我们可以通过相同的方法来对 Controller 层进行重构\n\n```java\n// Controller 层的基类\npublic abstract class AbstractCrudController<T extends ICrudService<E, ID>, E, ID> {\n    private T service;\n    public AbstractCrudController(T service) {\n        this.service = service;\n    }\n\n    @GetMapping\n    @ResponseBody\n    public List<E> fetch() {\n        return this.service.findAll();\n    }\n\n    @GetMapping(\"{id}\")\n    @ResponseBody\n    public E get(@PathVariable(\"id\") ID id) {\n        // 由于是示例这里就不考虑没有数据的情况了\n        return this.service.findById(id).get();\n    }\n\n    @PostMapping\n    @ResponseBody\n    public E create(@RequestBody E e) {\n        return this.service.save(e);\n    }\n\n    @PutMapping(\"{id}\")\n    @ResponseBody\n    public E update(@RequestBody E e) {\n        return this.service.save(e);\n    }\n\n    @DeleteMapping(\"{id}\")\n    @ResponseBody\n    public E delete(@PathVariable(\"id\") ID id) {\n        E e = this.service.findById(id).get();\n        this.service.deleteById(id);\n        return e;\n    }\n}\n\n// 具体的 WebAPI\n@RestController\n@RequestMapping(\"/user/\")\npublic class UserController extends AbstractCrudController<UserService, User, Long> {\n    public UserController(UserService service) {\n        super(service);\n    }\n}\n```\n\n经过重构可以消减掉 Servcie 和 Controller 中的大量重复代码，使代码更容易维护了。\n\n## 4. 结尾\n\n关于泛型就简单的说这些了，泛型作为 Java 日常开发中一个常用的知识点，其实还有很多知识点可以供我们挖掘，奈何本人才疏学浅，这么多年工作下来，只积累出来这么点内容。\n\n文末放上示例代码的代码库: \n\n- [GitHub入口](https://github.com/hashmaparraylist/re-study-java)\n- [gitee入口](https://gitee.com/hashmaparraylist/re-study-java)\n\n","slug":"重学Java-一-泛型","published":1,"updated":"2023-07-04T12:26:10.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljo9zkjs000f4goihc0y4xef","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>泛型编程自从 Java 5.0 中引入后已经超过15个年头了。对于现在的 Java 码农来说熟练使用泛型编程已经是家常便饭的事情了。所以本文就在不对泛型的基础使用在做说明了。 如果你还不会使用泛型的话，可以参考下面两个链接</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_24084925/article/details/68491132\">Java 泛型详解</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/generics/index.html\">The Java™ Tutorials (Lesson: Generics)</a></li>\n</ul>\n<p>这篇文章就简答聊一下，我实际在开发工作中很少用的到泛型方法这个知识点，以及在实际项目中有哪些东西会使用到泛型。</p>\n<h2 id=\"2-泛型方法\"><a href=\"#2-泛型方法\" class=\"headerlink\" title=\"2. 泛型方法\"></a>2. 泛型方法</h2><p>在阅读代码的时候我们经常会看到下面这样的方法 (这段代码摘自 <code>java.util.AbstractCollection</code>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> size();</span><br><span class=\"line\">    T[] r = a.length &gt;= size ? a :</span><br><span class=\"line\">              (T[])java.lang.reflect.Array</span><br><span class=\"line\">              .newInstance(a.getClass().getComponentType(), size);</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! it.hasNext()) &#123; <span class=\"comment\">// fewer elements than expected</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a == r) &#123;</span><br><span class=\"line\">                r[i] = <span class=\"literal\">null</span>; <span class=\"comment\">// null-terminate</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a.length &lt; i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Arrays.copyOf(r, i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.arraycopy(r, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a.length &gt; i) &#123;</span><br><span class=\"line\">                    a[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r[i] = (T)it.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// more elements than expected</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么 <code>pulic</code> 关键字后面的那个 <code>&lt;T&gt;</code> 就是用来标记这个方法是一个泛型方法。 那什么是泛型方法呢。</p>\n<p>官方的解释是这样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#x27;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.</span><br></pre></td></tr></table></figure>\n\n<p>通俗点来将就是将一个方法泛型化，让一个普通的类的某一个方法具有泛型功能。 如果在一个泛型类中增加一个泛型方法，那这个泛型方法就可以有一套独立于这个类的泛型类型。</p>\n<p>通过一个简单的例子, 我们来看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * GenericClass 这个泛型类是一个简单的套皮的 HashMap</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GenericClass</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;K, V&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> map.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(K key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 泛型方法 genericMethod 可以接受一个全新的、作用域只限本函数的泛型类型T</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">genericMethod</span><span class=\"params\">(T t)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际使用起来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericClass&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">GenericClass</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// put 和 get 方法的参数必须使用定义时指定的 String 和 Integer</span></span><br><span class=\"line\">System.out.println(map.put(<span class=\"string\">&quot;One&quot;</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">System.out.println(map.get(<span class=\"string\">&quot;One&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 泛型方法 genericMethod 就可以接受一个 String 和 Integer 以外的类型</span></span><br><span class=\"line\">System.out.println(map.genericMethod(<span class=\"keyword\">new</span> <span class=\"title class_\">Double</span>(<span class=\"number\">1.0</span>)).getClass());</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看 JDK 中使用到泛型方法的例子。我们最常使用的泛型容器 <code>ArrayList</code> 中有个 <code>toArray</code> 方法。JDK 在它的实现中就提供了两个版本，其中一个就是泛型方法的版本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个普通版本，返回一个Object的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这是一个泛型方法的版本，将容器里存储的元素输出到 T[] 数组中。 其中 T 必须是 E 的父类，否则 System.arraycopy 会抛出 ArrayStoreException 异常      </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>泛型方法总体上来说就是可以给与现有的方法实现上，增加一个更加灵活的实现可能。</p>\n<h2 id=\"3-实战应用\"><a href=\"#3-实战应用\" class=\"headerlink\" title=\"3. 实战应用\"></a>3. 实战应用</h2><p>在实际的项目中，对于泛型的使用，除了像倾倒垃圾一样往泛型容易里塞各种 java bean 和其他泛型对象。还能怎么使用泛型呢？</p>\n<p>我们在实际的一些项目中，会对数据库中的一些表(多数时候是全部)先实现 CRUD (Create, Read, Update, Delete)的操作，并从这些操作中延伸出一些简单的 REST 风格的 WebAPI 接口，然后才会根据实际业务需要实现一些更复杂的业务接口。 </p>\n<p>大体上会是下面这个样子。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这是一个简单的 Entity 对象</span></span><br><span class=\"line\"><span class=\"comment\">// 通常现在的 Java 应用都会使用到 Lombok 和 Spring Boot</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@ToString</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = &quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后这个是 DAO 接口继承自 spring-data 的 JpaRepository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在来是一个访问 User 资源的 Service 和他的实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    List&lt;User&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Optional&lt;User&gt; <span class=\"title function_\">findById</span><span class=\"params\">(Long id)</span>;</span><br><span class=\"line\">    User <span class=\"title function_\">save</span> <span class=\"params\">(User user)</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(Long id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserSerivceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserServiceImpl</span><span class=\"params\">(UserDao userDao)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userDao = userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Optional&lt;User&gt; <span class=\"title function_\">findById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">save</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.save(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dao.deleteById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最后就是 WebAPI 的接口了</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserController</span><span class=\"params\">(userService userService)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title function_\">fetch</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于是示例这里就不考虑没有数据的情况了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.findById(id).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.save(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.save(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">delete</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.userService.findById(id);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userService.deleteById(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致一个表的一套相关接口就是这个样子的。如果你的数据库中有大量表的话，而且每个表都需要提供 REST 风格的 WebAPI 接口的话，那么这将是一个相当枯燥的而又及其容易出错的工作。</p>\n<p>为了不让这项枯燥而又容易犯错的工作占去我们宝贵的私人时间，我们可以通过泛型和继承的技巧来重构从 Service 层到 Controller 的这段代码(感谢 spring-data 提供了 <code>JpaRepository</code>, 让我们不至于从 DAO 层重构)</p>\n<h2 id=\"3-1-Service-层的重构\"><a href=\"#3-1-Service-层的重构\" class=\"headerlink\" title=\"3.1 Service 层的重构\"></a>3.1 Service 层的重构</h2><p>首先是 Service 接口的重构，我们 Service 层接口就是定义了一组 CRUD 的操作，我们可以将这组 CRUD 操作抽象到一个父接口，然后所有 Service 层的接口都将继承自这个父接口。而接口中出现的 Entity 和主键的类型(上例中 User 的主键 id 的类型是 Long)就可以用泛型来展现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里泛型表示 E 来指代 Entity, ID 用来指代 Entity 主键的类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICrudService</span>&lt;E, ID&gt; &#123;</span><br><span class=\"line\">    List&lt;E&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Optional&lt;E&gt; <span class=\"title function_\">findById</span><span class=\"params\">(ID id)</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">save</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(ID id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后 Service 层的接口，就可以简化成这样</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ICrudService</span>&lt;User, Long&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样 Service 层的实现也可以使用相似的方法具体实现可以抽象到一个基类中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 相比 ICrudService 这里有多了一个泛型 T 来代表 Entity 对应的 DAO, 我们的每一个 DAO 都继承自</span></span><br><span class=\"line\"><span class=\"comment\">// spring-data 的 JpaRepository 所以，这里可以使用到泛型的边界</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractCrudService</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;E, ID&gt;, E, ID&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T dao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AbstractCrudService</span><span class=\"params\">(T dao)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dao = dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Optional&lt;E&gt; <span class=\"title function_\">findById</span><span class=\"params\">(ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">save</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.save(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dao.deleteById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那 Service 的实现类可以简化成这样</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractCrudService</span>&lt;UserDao, User, Long&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserServiceImpl</span><span class=\"params\">(UserDao dao)</span> &#123;</span><br><span class=\"line\">        supper(dao);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样我们可以通过相同的方法来对 Controller 层进行重构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controller 层的基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractCrudController</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">ICrudService</span>&lt;E, ID&gt;, E, ID&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T service;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AbstractCrudController</span><span class=\"params\">(T service)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title function_\">fetch</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于是示例这里就不考虑没有数据的情况了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.findById(id).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.save(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.save(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">delete</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.service.findById(id).get();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service.deleteById(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体的 WebAPI</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractCrudController</span>&lt;UserService, User, Long&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserController</span><span class=\"params\">(UserService service)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过重构可以消减掉 Servcie 和 Controller 中的大量重复代码，使代码更容易维护了。</p>\n<h2 id=\"4-结尾\"><a href=\"#4-结尾\" class=\"headerlink\" title=\"4. 结尾\"></a>4. 结尾</h2><p>关于泛型就简单的说这些了，泛型作为 Java 日常开发中一个常用的知识点，其实还有很多知识点可以供我们挖掘，奈何本人才疏学浅，这么多年工作下来，只积累出来这么点内容。</p>\n<p>文末放上示例代码的代码库: </p>\n<ul>\n<li><a href=\"https://github.com/hashmaparraylist/re-study-java\">GitHub入口</a></li>\n<li><a href=\"https://gitee.com/hashmaparraylist/re-study-java\">gitee入口</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>泛型编程自从 Java 5.0 中引入后已经超过15个年头了。对于现在的 Java 码农来说熟练使用泛型编程已经是家常便饭的事情了。所以本文就在不对泛型的基础使用在做说明了。 如果你还不会使用泛型的话，可以参考下面两个链接</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_24084925/article/details/68491132\">Java 泛型详解</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/generics/index.html\">The Java™ Tutorials (Lesson: Generics)</a></li>\n</ul>\n<p>这篇文章就简答聊一下，我实际在开发工作中很少用的到泛型方法这个知识点，以及在实际项目中有哪些东西会使用到泛型。</p>\n<h2 id=\"2-泛型方法\"><a href=\"#2-泛型方法\" class=\"headerlink\" title=\"2. 泛型方法\"></a>2. 泛型方法</h2><p>在阅读代码的时候我们经常会看到下面这样的方法 (这段代码摘自 <code>java.util.AbstractCollection</code>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Estimate size of array; be prepared to see more or fewer elements</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> size();</span><br><span class=\"line\">    T[] r = a.length &gt;= size ? a :</span><br><span class=\"line\">              (T[])java.lang.reflect.Array</span><br><span class=\"line\">              .newInstance(a.getClass().getComponentType(), size);</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; r.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! it.hasNext()) &#123; <span class=\"comment\">// fewer elements than expected</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a == r) &#123;</span><br><span class=\"line\">                r[i] = <span class=\"literal\">null</span>; <span class=\"comment\">// null-terminate</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a.length &lt; i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Arrays.copyOf(r, i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.arraycopy(r, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a.length &gt; i) &#123;</span><br><span class=\"line\">                    a[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r[i] = (T)it.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// more elements than expected</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么 <code>pulic</code> 关键字后面的那个 <code>&lt;T&gt;</code> 就是用来标记这个方法是一个泛型方法。 那什么是泛型方法呢。</p>\n<p>官方的解释是这样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter&#x27;s scope is limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.</span><br></pre></td></tr></table></figure>\n\n<p>通俗点来将就是将一个方法泛型化，让一个普通的类的某一个方法具有泛型功能。 如果在一个泛型类中增加一个泛型方法，那这个泛型方法就可以有一套独立于这个类的泛型类型。</p>\n<p>通过一个简单的例子, 我们来看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * GenericClass 这个泛型类是一个简单的套皮的 HashMap</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GenericClass</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;K, V&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> map.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(K key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 泛型方法 genericMethod 可以接受一个全新的、作用域只限本函数的泛型类型T</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">genericMethod</span><span class=\"params\">(T t)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际使用起来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericClass&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">GenericClass</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// put 和 get 方法的参数必须使用定义时指定的 String 和 Integer</span></span><br><span class=\"line\">System.out.println(map.put(<span class=\"string\">&quot;One&quot;</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">System.out.println(map.get(<span class=\"string\">&quot;One&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 泛型方法 genericMethod 就可以接受一个 String 和 Integer 以外的类型</span></span><br><span class=\"line\">System.out.println(map.genericMethod(<span class=\"keyword\">new</span> <span class=\"title class_\">Double</span>(<span class=\"number\">1.0</span>)).getClass());</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看看 JDK 中使用到泛型方法的例子。我们最常使用的泛型容器 <code>ArrayList</code> 中有个 <code>toArray</code> 方法。JDK 在它的实现中就提供了两个版本，其中一个就是泛型方法的版本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个普通版本，返回一个Object的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object[] toArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这是一个泛型方法的版本，将容器里存储的元素输出到 T[] 数组中。 其中 T 必须是 E 的父类，否则 System.arraycopy 会抛出 ArrayStoreException 异常      </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &lt; size)</span><br><span class=\"line\">            <span class=\"comment\">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class=\"line\">        System.arraycopy(elementData, <span class=\"number\">0</span>, a, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a.length &gt; size)</span><br><span class=\"line\">            a[size] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>泛型方法总体上来说就是可以给与现有的方法实现上，增加一个更加灵活的实现可能。</p>\n<h2 id=\"3-实战应用\"><a href=\"#3-实战应用\" class=\"headerlink\" title=\"3. 实战应用\"></a>3. 实战应用</h2><p>在实际的项目中，对于泛型的使用，除了像倾倒垃圾一样往泛型容易里塞各种 java bean 和其他泛型对象。还能怎么使用泛型呢？</p>\n<p>我们在实际的一些项目中，会对数据库中的一些表(多数时候是全部)先实现 CRUD (Create, Read, Update, Delete)的操作，并从这些操作中延伸出一些简单的 REST 风格的 WebAPI 接口，然后才会根据实际业务需要实现一些更复杂的业务接口。 </p>\n<p>大体上会是下面这个样子。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这是一个简单的 Entity 对象</span></span><br><span class=\"line\"><span class=\"comment\">// 通常现在的 Java 应用都会使用到 Lombok 和 Spring Boot</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@ToString</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table(name = &quot;user&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后这个是 DAO 接口继承自 spring-data 的 JpaRepository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在来是一个访问 User 资源的 Service 和他的实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    List&lt;User&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Optional&lt;User&gt; <span class=\"title function_\">findById</span><span class=\"params\">(Long id)</span>;</span><br><span class=\"line\">    User <span class=\"title function_\">save</span> <span class=\"params\">(User user)</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(Long id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserSerivceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserServiceImpl</span><span class=\"params\">(UserDao userDao)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userDao = userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Optional&lt;User&gt; <span class=\"title function_\">findById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">save</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.save(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dao.deleteById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最后就是 WebAPI 的接口了</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserController</span><span class=\"params\">(userService userService)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userService = userService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title function_\">fetch</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于是示例这里就不考虑没有数据的情况了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.findById(id).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.save(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userService.save(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">delete</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.userService.findById(id);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userService.deleteById(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致一个表的一套相关接口就是这个样子的。如果你的数据库中有大量表的话，而且每个表都需要提供 REST 风格的 WebAPI 接口的话，那么这将是一个相当枯燥的而又及其容易出错的工作。</p>\n<p>为了不让这项枯燥而又容易犯错的工作占去我们宝贵的私人时间，我们可以通过泛型和继承的技巧来重构从 Service 层到 Controller 的这段代码(感谢 spring-data 提供了 <code>JpaRepository</code>, 让我们不至于从 DAO 层重构)</p>\n<h2 id=\"3-1-Service-层的重构\"><a href=\"#3-1-Service-层的重构\" class=\"headerlink\" title=\"3.1 Service 层的重构\"></a>3.1 Service 层的重构</h2><p>首先是 Service 接口的重构，我们 Service 层接口就是定义了一组 CRUD 的操作，我们可以将这组 CRUD 操作抽象到一个父接口，然后所有 Service 层的接口都将继承自这个父接口。而接口中出现的 Entity 和主键的类型(上例中 User 的主键 id 的类型是 Long)就可以用泛型来展现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里泛型表示 E 来指代 Entity, ID 用来指代 Entity 主键的类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ICrudService</span>&lt;E, ID&gt; &#123;</span><br><span class=\"line\">    List&lt;E&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Optional&lt;E&gt; <span class=\"title function_\">findById</span><span class=\"params\">(ID id)</span>;</span><br><span class=\"line\">    E <span class=\"title function_\">save</span><span class=\"params\">(E e)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(ID id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后 Service 层的接口，就可以简化成这样</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ICrudService</span>&lt;User, Long&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样 Service 层的实现也可以使用相似的方法具体实现可以抽象到一个基类中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 相比 ICrudService 这里有多了一个泛型 T 来代表 Entity 对应的 DAO, 我们的每一个 DAO 都继承自</span></span><br><span class=\"line\"><span class=\"comment\">// spring-data 的 JpaRepository 所以，这里可以使用到泛型的边界</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractCrudService</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;E, ID&gt;, E, ID&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T dao;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AbstractCrudService</span><span class=\"params\">(T dao)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dao = dao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title function_\">findAll</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Optional&lt;E&gt; <span class=\"title function_\">findById</span><span class=\"params\">(ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.findById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">save</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.dao.save(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteById</span><span class=\"params\">(ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dao.deleteById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那 Service 的实现类可以简化成这样</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractCrudService</span>&lt;UserDao, User, Long&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserServiceImpl</span><span class=\"params\">(UserDao dao)</span> &#123;</span><br><span class=\"line\">        supper(dao);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样我们可以通过相同的方法来对 Controller 层进行重构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controller 层的基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractCrudController</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">ICrudService</span>&lt;E, ID&gt;, E, ID&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T service;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AbstractCrudController</span><span class=\"params\">(T service)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title function_\">fetch</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.findAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于是示例这里就不考虑没有数据的情况了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.findById(id).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.save(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.service.save(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">delete</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> ID id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.service.findById(id).get();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service.deleteById(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体的 WebAPI</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractCrudController</span>&lt;UserService, User, Long&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserController</span><span class=\"params\">(UserService service)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过重构可以消减掉 Servcie 和 Controller 中的大量重复代码，使代码更容易维护了。</p>\n<h2 id=\"4-结尾\"><a href=\"#4-结尾\" class=\"headerlink\" title=\"4. 结尾\"></a>4. 结尾</h2><p>关于泛型就简单的说这些了，泛型作为 Java 日常开发中一个常用的知识点，其实还有很多知识点可以供我们挖掘，奈何本人才疏学浅，这么多年工作下来，只积累出来这么点内容。</p>\n<p>文末放上示例代码的代码库: </p>\n<ul>\n<li><a href=\"https://github.com/hashmaparraylist/re-study-java\">GitHub入口</a></li>\n<li><a href=\"https://gitee.com/hashmaparraylist/re-study-java\">gitee入口</a></li>\n</ul>\n"},{"title":"H项目心路历程记 (一)","date":"2023-07-10T03:19:00.000Z","_content":"\n\n# 前言\n\n2021年年中从前一家公司离职，经过朋友介绍到了现在公司参与了`Halfling`项目(以下简称`H项目`)，并从零开始的设计开发到第一个客户交付的全部流程。\n\n`H项目`是一个面向零售行业在电商时代的智能一体化中台产品。项目最早是从2021年中开始立项投入，期间经过数个版本迭代，以及2022年初的魔都封城等诸多困难。终于在2023年Q2季度完成了针对首个客户的上线。\n\n作为从头开始全程参与项目的技术人员，经过2年多的产品研发期间有不少想吐槽和想说的。\n\n# 业务设计\n\n最初`H项目`是以打造一个面向零售行业业务中台为目的进行项目立项的，其中一个很重要的点就是希望除核心组件以外都可以独立售卖。所以在架构设计的使用当下最流行的微服务架构(基于Spring Boot + Kubernetes集群的解决方案), 再做业务拆分到服务的时候，进行了更细颗粒度的拆分。所以前前后后一共拆分了近20个微服务。\n\n实际上到了2022年Q2前后，两个核心服务订单管理和库存服务实现以后发现，各个业务服务中间的耦合程度比想象中的还要精密，单个服务拆开单独售卖几乎不可能(应该说是完全不可能)。 然而由于服务拆分的过细，导致一个服务需要频繁访问其他服务获取大量数据。尤其类似订单关联数据比如商品的主档数据，会穿越好几个服务。而每个服务都会重复去获取主档数据，造成了大量的额外请求。 虽然最后在所有服务底部兜底使用同一个Redis作为缓存来减少额外的请求调用。\n\n随着时间来到2023年产品组负责人离职后，整个`H项目`的方向有从行业的业务中台降级成中小企业的订单管理系统(`Order Management System`, OMS)。前期做的很多设计比如用户权限体系(当初需求是要精确到每个页面的每个按钮，如果下拉列表框有外调请求也需要做权限控制)等就显的很重，导致用户在使用以及配置都很不方便。而有些设计就显得稍显欠缺。 所以整个2022年Q4到2023年都是在对业务层上反复横跳，比如库存模型和商品模型的调整。这点是相当影响团队士气，同时也加剧了研发组和产品组之间的矛盾。\n\n然后还有一个很重要的问题是多租户的态度上。早起项目是以服务中大体量客户为目的，所以设计之初并没有考虑多租户的问题。但实际项的进展过程中发现部分中大体量的客户也需要类似多租户的功能。这类客户需求与其说是需求多租户，不如说是希望有一个多租户级别的数据隔离，每个业务部门只能操作自己的业务部门的数据(数据包含商品，品牌，属性，平台店铺，订单，售后单据等)，而总部依据可以查看一些汇总信息(例如销售对账单据等)。而随着2022年疫情状况严峻，很多中大客户对于内部平台升级和替换都变的更加谨慎和保守。所以当项目方向变成中小企业OMS时，多租户SaaS化的需求就更加迫切了。所以后期如何在原有系统上在扩展一套多租户SaaS化功能也是个课题。\n\n# 中间件\n\n`H项目`使用的中间件中比较特别的有分布式任务管理系统`xxl-job`，消息队列`RocketMQ`，这两个中间件都是第一次使用。关于这两个中间件也有不是可以谈谈的。\n\n## 分布式任务管理系统 `XXL-JOB`\n\n作为一个开源的分布式任务管理系统，`xxl-job`足够简单且相当容易上手使用，无论是基于Spring，还是原生Java做开发都是相当简单的。\n\n而不足之处也很明显，最近1年版本迭代速度明显变慢，有些功能和BUG都有待处理的。比如想实动态创建定时任务这类功能就必须自己动手去对`xxl-job-admin`(调度中心)进行修改。\n\n对于任务执行日志这块，现在`xxl-job`也是文件格式在执行器所在服务器上进行输出的，当执行器容器化或是运行在Kubernetes集群中的时候，当容器或是Pod重启后，就会丢失日志。这点在后期运维以及调试上还是有点麻烦的。\n\n## 消息队列 `RocketMQ`\n\n阿里出品的消息队列如果基于云产品来使用的话问题不大(阿里云卖的价钱也是有点黑的)，但是在运维上还是有点问题的比如Topic,Group这些东西都只能人工去添加，阿里云并没有提供导入服务。全系统如果使用消息队列的场景多的话，维护这些Topic和Group还是很酸爽的。还有一点`RocketMQ`重复消息这一点是无法保证的。用阿里云的原话\n\n> 绝大多数情况下，消息是不重复的。作为一款分布式消息中间件，在网络抖动、应用处理超时等异常情况下，无法保证消息不重复，但是能保证消息不丢失。\n\n实际运用上，在大数据量并发的情况下，我们实际上是遇到了消息重复消费的问题。这点还是需要通过代码干预(例如增加一个唯一MsgId，对MsgId做分布式锁来解决)。\n\n还有一点就是在旧版本SDK的默认配置下消费者的负载是有点小问题，总是有一个节点会比其他节点更容易消费到大量消息。据阿里云自己说明在新版本SDK的默认负载配置也已经修复这个问题了。\n\n\n**(未完待续)**\n\n","source":"_posts/H项目心路历程记-1.md","raw":"---\ntitle: H项目心路历程记 (一)\ntags:\n  - 架构\n  - Kubernetes\n  - Aliyun\n  - Java\ncategories:\n  - 设计\ndate: 2023-07-10 11:19:00\n---\n\n\n# 前言\n\n2021年年中从前一家公司离职，经过朋友介绍到了现在公司参与了`Halfling`项目(以下简称`H项目`)，并从零开始的设计开发到第一个客户交付的全部流程。\n\n`H项目`是一个面向零售行业在电商时代的智能一体化中台产品。项目最早是从2021年中开始立项投入，期间经过数个版本迭代，以及2022年初的魔都封城等诸多困难。终于在2023年Q2季度完成了针对首个客户的上线。\n\n作为从头开始全程参与项目的技术人员，经过2年多的产品研发期间有不少想吐槽和想说的。\n\n# 业务设计\n\n最初`H项目`是以打造一个面向零售行业业务中台为目的进行项目立项的，其中一个很重要的点就是希望除核心组件以外都可以独立售卖。所以在架构设计的使用当下最流行的微服务架构(基于Spring Boot + Kubernetes集群的解决方案), 再做业务拆分到服务的时候，进行了更细颗粒度的拆分。所以前前后后一共拆分了近20个微服务。\n\n实际上到了2022年Q2前后，两个核心服务订单管理和库存服务实现以后发现，各个业务服务中间的耦合程度比想象中的还要精密，单个服务拆开单独售卖几乎不可能(应该说是完全不可能)。 然而由于服务拆分的过细，导致一个服务需要频繁访问其他服务获取大量数据。尤其类似订单关联数据比如商品的主档数据，会穿越好几个服务。而每个服务都会重复去获取主档数据，造成了大量的额外请求。 虽然最后在所有服务底部兜底使用同一个Redis作为缓存来减少额外的请求调用。\n\n随着时间来到2023年产品组负责人离职后，整个`H项目`的方向有从行业的业务中台降级成中小企业的订单管理系统(`Order Management System`, OMS)。前期做的很多设计比如用户权限体系(当初需求是要精确到每个页面的每个按钮，如果下拉列表框有外调请求也需要做权限控制)等就显的很重，导致用户在使用以及配置都很不方便。而有些设计就显得稍显欠缺。 所以整个2022年Q4到2023年都是在对业务层上反复横跳，比如库存模型和商品模型的调整。这点是相当影响团队士气，同时也加剧了研发组和产品组之间的矛盾。\n\n然后还有一个很重要的问题是多租户的态度上。早起项目是以服务中大体量客户为目的，所以设计之初并没有考虑多租户的问题。但实际项的进展过程中发现部分中大体量的客户也需要类似多租户的功能。这类客户需求与其说是需求多租户，不如说是希望有一个多租户级别的数据隔离，每个业务部门只能操作自己的业务部门的数据(数据包含商品，品牌，属性，平台店铺，订单，售后单据等)，而总部依据可以查看一些汇总信息(例如销售对账单据等)。而随着2022年疫情状况严峻，很多中大客户对于内部平台升级和替换都变的更加谨慎和保守。所以当项目方向变成中小企业OMS时，多租户SaaS化的需求就更加迫切了。所以后期如何在原有系统上在扩展一套多租户SaaS化功能也是个课题。\n\n# 中间件\n\n`H项目`使用的中间件中比较特别的有分布式任务管理系统`xxl-job`，消息队列`RocketMQ`，这两个中间件都是第一次使用。关于这两个中间件也有不是可以谈谈的。\n\n## 分布式任务管理系统 `XXL-JOB`\n\n作为一个开源的分布式任务管理系统，`xxl-job`足够简单且相当容易上手使用，无论是基于Spring，还是原生Java做开发都是相当简单的。\n\n而不足之处也很明显，最近1年版本迭代速度明显变慢，有些功能和BUG都有待处理的。比如想实动态创建定时任务这类功能就必须自己动手去对`xxl-job-admin`(调度中心)进行修改。\n\n对于任务执行日志这块，现在`xxl-job`也是文件格式在执行器所在服务器上进行输出的，当执行器容器化或是运行在Kubernetes集群中的时候，当容器或是Pod重启后，就会丢失日志。这点在后期运维以及调试上还是有点麻烦的。\n\n## 消息队列 `RocketMQ`\n\n阿里出品的消息队列如果基于云产品来使用的话问题不大(阿里云卖的价钱也是有点黑的)，但是在运维上还是有点问题的比如Topic,Group这些东西都只能人工去添加，阿里云并没有提供导入服务。全系统如果使用消息队列的场景多的话，维护这些Topic和Group还是很酸爽的。还有一点`RocketMQ`重复消息这一点是无法保证的。用阿里云的原话\n\n> 绝大多数情况下，消息是不重复的。作为一款分布式消息中间件，在网络抖动、应用处理超时等异常情况下，无法保证消息不重复，但是能保证消息不丢失。\n\n实际运用上，在大数据量并发的情况下，我们实际上是遇到了消息重复消费的问题。这点还是需要通过代码干预(例如增加一个唯一MsgId，对MsgId做分布式锁来解决)。\n\n还有一点就是在旧版本SDK的默认配置下消费者的负载是有点小问题，总是有一个节点会比其他节点更容易消费到大量消息。据阿里云自己说明在新版本SDK的默认负载配置也已经修复这个问题了。\n\n\n**(未完待续)**\n\n","slug":"H项目心路历程记-1","published":1,"updated":"2023-07-10T09:17:01.579Z","_id":"cljwneykb0006m3oi131phei7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>2021年年中从前一家公司离职，经过朋友介绍到了现在公司参与了<code>Halfling</code>项目(以下简称<code>H项目</code>)，并从零开始的设计开发到第一个客户交付的全部流程。</p>\n<p><code>H项目</code>是一个面向零售行业在电商时代的智能一体化中台产品。项目最早是从2021年中开始立项投入，期间经过数个版本迭代，以及2022年初的魔都封城等诸多困难。终于在2023年Q2季度完成了针对首个客户的上线。</p>\n<p>作为从头开始全程参与项目的技术人员，经过2年多的产品研发期间有不少想吐槽和想说的。</p>\n<h1 id=\"业务设计\"><a href=\"#业务设计\" class=\"headerlink\" title=\"业务设计\"></a>业务设计</h1><p>最初<code>H项目</code>是以打造一个面向零售行业业务中台为目的进行项目立项的，其中一个很重要的点就是希望除核心组件以外都可以独立售卖。所以在架构设计的使用当下最流行的微服务架构(基于Spring Boot + Kubernetes集群的解决方案), 再做业务拆分到服务的时候，进行了更细颗粒度的拆分。所以前前后后一共拆分了近20个微服务。</p>\n<p>实际上到了2022年Q2前后，两个核心服务订单管理和库存服务实现以后发现，各个业务服务中间的耦合程度比想象中的还要精密，单个服务拆开单独售卖几乎不可能(应该说是完全不可能)。 然而由于服务拆分的过细，导致一个服务需要频繁访问其他服务获取大量数据。尤其类似订单关联数据比如商品的主档数据，会穿越好几个服务。而每个服务都会重复去获取主档数据，造成了大量的额外请求。 虽然最后在所有服务底部兜底使用同一个Redis作为缓存来减少额外的请求调用。</p>\n<p>随着时间来到2023年产品组负责人离职后，整个<code>H项目</code>的方向有从行业的业务中台降级成中小企业的订单管理系统(<code>Order Management System</code>, OMS)。前期做的很多设计比如用户权限体系(当初需求是要精确到每个页面的每个按钮，如果下拉列表框有外调请求也需要做权限控制)等就显的很重，导致用户在使用以及配置都很不方便。而有些设计就显得稍显欠缺。 所以整个2022年Q4到2023年都是在对业务层上反复横跳，比如库存模型和商品模型的调整。这点是相当影响团队士气，同时也加剧了研发组和产品组之间的矛盾。</p>\n<p>然后还有一个很重要的问题是多租户的态度上。早起项目是以服务中大体量客户为目的，所以设计之初并没有考虑多租户的问题。但实际项的进展过程中发现部分中大体量的客户也需要类似多租户的功能。这类客户需求与其说是需求多租户，不如说是希望有一个多租户级别的数据隔离，每个业务部门只能操作自己的业务部门的数据(数据包含商品，品牌，属性，平台店铺，订单，售后单据等)，而总部依据可以查看一些汇总信息(例如销售对账单据等)。而随着2022年疫情状况严峻，很多中大客户对于内部平台升级和替换都变的更加谨慎和保守。所以当项目方向变成中小企业OMS时，多租户SaaS化的需求就更加迫切了。所以后期如何在原有系统上在扩展一套多租户SaaS化功能也是个课题。</p>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><p><code>H项目</code>使用的中间件中比较特别的有分布式任务管理系统<code>xxl-job</code>，消息队列<code>RocketMQ</code>，这两个中间件都是第一次使用。关于这两个中间件也有不是可以谈谈的。</p>\n<h2 id=\"分布式任务管理系统-XXL-JOB\"><a href=\"#分布式任务管理系统-XXL-JOB\" class=\"headerlink\" title=\"分布式任务管理系统 XXL-JOB\"></a>分布式任务管理系统 <code>XXL-JOB</code></h2><p>作为一个开源的分布式任务管理系统，<code>xxl-job</code>足够简单且相当容易上手使用，无论是基于Spring，还是原生Java做开发都是相当简单的。</p>\n<p>而不足之处也很明显，最近1年版本迭代速度明显变慢，有些功能和BUG都有待处理的。比如想实动态创建定时任务这类功能就必须自己动手去对<code>xxl-job-admin</code>(调度中心)进行修改。</p>\n<p>对于任务执行日志这块，现在<code>xxl-job</code>也是文件格式在执行器所在服务器上进行输出的，当执行器容器化或是运行在Kubernetes集群中的时候，当容器或是Pod重启后，就会丢失日志。这点在后期运维以及调试上还是有点麻烦的。</p>\n<h2 id=\"消息队列-RocketMQ\"><a href=\"#消息队列-RocketMQ\" class=\"headerlink\" title=\"消息队列 RocketMQ\"></a>消息队列 <code>RocketMQ</code></h2><p>阿里出品的消息队列如果基于云产品来使用的话问题不大(阿里云卖的价钱也是有点黑的)，但是在运维上还是有点问题的比如Topic,Group这些东西都只能人工去添加，阿里云并没有提供导入服务。全系统如果使用消息队列的场景多的话，维护这些Topic和Group还是很酸爽的。还有一点<code>RocketMQ</code>重复消息这一点是无法保证的。用阿里云的原话</p>\n<blockquote>\n<p>绝大多数情况下，消息是不重复的。作为一款分布式消息中间件，在网络抖动、应用处理超时等异常情况下，无法保证消息不重复，但是能保证消息不丢失。</p>\n</blockquote>\n<p>实际运用上，在大数据量并发的情况下，我们实际上是遇到了消息重复消费的问题。这点还是需要通过代码干预(例如增加一个唯一MsgId，对MsgId做分布式锁来解决)。</p>\n<p>还有一点就是在旧版本SDK的默认配置下消费者的负载是有点小问题，总是有一个节点会比其他节点更容易消费到大量消息。据阿里云自己说明在新版本SDK的默认负载配置也已经修复这个问题了。</p>\n<p><strong>(未完待续)</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>2021年年中从前一家公司离职，经过朋友介绍到了现在公司参与了<code>Halfling</code>项目(以下简称<code>H项目</code>)，并从零开始的设计开发到第一个客户交付的全部流程。</p>\n<p><code>H项目</code>是一个面向零售行业在电商时代的智能一体化中台产品。项目最早是从2021年中开始立项投入，期间经过数个版本迭代，以及2022年初的魔都封城等诸多困难。终于在2023年Q2季度完成了针对首个客户的上线。</p>\n<p>作为从头开始全程参与项目的技术人员，经过2年多的产品研发期间有不少想吐槽和想说的。</p>\n<h1 id=\"业务设计\"><a href=\"#业务设计\" class=\"headerlink\" title=\"业务设计\"></a>业务设计</h1><p>最初<code>H项目</code>是以打造一个面向零售行业业务中台为目的进行项目立项的，其中一个很重要的点就是希望除核心组件以外都可以独立售卖。所以在架构设计的使用当下最流行的微服务架构(基于Spring Boot + Kubernetes集群的解决方案), 再做业务拆分到服务的时候，进行了更细颗粒度的拆分。所以前前后后一共拆分了近20个微服务。</p>\n<p>实际上到了2022年Q2前后，两个核心服务订单管理和库存服务实现以后发现，各个业务服务中间的耦合程度比想象中的还要精密，单个服务拆开单独售卖几乎不可能(应该说是完全不可能)。 然而由于服务拆分的过细，导致一个服务需要频繁访问其他服务获取大量数据。尤其类似订单关联数据比如商品的主档数据，会穿越好几个服务。而每个服务都会重复去获取主档数据，造成了大量的额外请求。 虽然最后在所有服务底部兜底使用同一个Redis作为缓存来减少额外的请求调用。</p>\n<p>随着时间来到2023年产品组负责人离职后，整个<code>H项目</code>的方向有从行业的业务中台降级成中小企业的订单管理系统(<code>Order Management System</code>, OMS)。前期做的很多设计比如用户权限体系(当初需求是要精确到每个页面的每个按钮，如果下拉列表框有外调请求也需要做权限控制)等就显的很重，导致用户在使用以及配置都很不方便。而有些设计就显得稍显欠缺。 所以整个2022年Q4到2023年都是在对业务层上反复横跳，比如库存模型和商品模型的调整。这点是相当影响团队士气，同时也加剧了研发组和产品组之间的矛盾。</p>\n<p>然后还有一个很重要的问题是多租户的态度上。早起项目是以服务中大体量客户为目的，所以设计之初并没有考虑多租户的问题。但实际项的进展过程中发现部分中大体量的客户也需要类似多租户的功能。这类客户需求与其说是需求多租户，不如说是希望有一个多租户级别的数据隔离，每个业务部门只能操作自己的业务部门的数据(数据包含商品，品牌，属性，平台店铺，订单，售后单据等)，而总部依据可以查看一些汇总信息(例如销售对账单据等)。而随着2022年疫情状况严峻，很多中大客户对于内部平台升级和替换都变的更加谨慎和保守。所以当项目方向变成中小企业OMS时，多租户SaaS化的需求就更加迫切了。所以后期如何在原有系统上在扩展一套多租户SaaS化功能也是个课题。</p>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><p><code>H项目</code>使用的中间件中比较特别的有分布式任务管理系统<code>xxl-job</code>，消息队列<code>RocketMQ</code>，这两个中间件都是第一次使用。关于这两个中间件也有不是可以谈谈的。</p>\n<h2 id=\"分布式任务管理系统-XXL-JOB\"><a href=\"#分布式任务管理系统-XXL-JOB\" class=\"headerlink\" title=\"分布式任务管理系统 XXL-JOB\"></a>分布式任务管理系统 <code>XXL-JOB</code></h2><p>作为一个开源的分布式任务管理系统，<code>xxl-job</code>足够简单且相当容易上手使用，无论是基于Spring，还是原生Java做开发都是相当简单的。</p>\n<p>而不足之处也很明显，最近1年版本迭代速度明显变慢，有些功能和BUG都有待处理的。比如想实动态创建定时任务这类功能就必须自己动手去对<code>xxl-job-admin</code>(调度中心)进行修改。</p>\n<p>对于任务执行日志这块，现在<code>xxl-job</code>也是文件格式在执行器所在服务器上进行输出的，当执行器容器化或是运行在Kubernetes集群中的时候，当容器或是Pod重启后，就会丢失日志。这点在后期运维以及调试上还是有点麻烦的。</p>\n<h2 id=\"消息队列-RocketMQ\"><a href=\"#消息队列-RocketMQ\" class=\"headerlink\" title=\"消息队列 RocketMQ\"></a>消息队列 <code>RocketMQ</code></h2><p>阿里出品的消息队列如果基于云产品来使用的话问题不大(阿里云卖的价钱也是有点黑的)，但是在运维上还是有点问题的比如Topic,Group这些东西都只能人工去添加，阿里云并没有提供导入服务。全系统如果使用消息队列的场景多的话，维护这些Topic和Group还是很酸爽的。还有一点<code>RocketMQ</code>重复消息这一点是无法保证的。用阿里云的原话</p>\n<blockquote>\n<p>绝大多数情况下，消息是不重复的。作为一款分布式消息中间件，在网络抖动、应用处理超时等异常情况下，无法保证消息不重复，但是能保证消息不丢失。</p>\n</blockquote>\n<p>实际运用上，在大数据量并发的情况下，我们实际上是遇到了消息重复消费的问题。这点还是需要通过代码干预(例如增加一个唯一MsgId，对MsgId做分布式锁来解决)。</p>\n<p>还有一点就是在旧版本SDK的默认配置下消费者的负载是有点小问题，总是有一个节点会比其他节点更容易消费到大量消息。据阿里云自己说明在新版本SDK的默认负载配置也已经修复这个问题了。</p>\n<p><strong>(未完待续)</strong></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cljo9zkjl00004goifkkd2ktv","category_id":"cljo9zkjo00024goi1kpe1pou","_id":"cljo9zkjr000c4goi0mq29xx4"},{"post_id":"cljo9zkjr000a4goihf3c0c7k","category_id":"cljo9zkjq00074goifz3v6gea","_id":"cljo9zkjs000g4goiet2734as"},{"post_id":"cljo9zkjs000f4goihc0y4xef","category_id":"cljo9zkjq00074goifz3v6gea","_id":"cljo9zkjt000k4goie1pbf53o"},{"post_id":"cljo9zkjp00044goibj6kewct","category_id":"cljo9zkjs000d4goi3nzx2545","_id":"cljo9zkjt000o4goidt4m82tf"},{"post_id":"cljo9zkjp00054goi3n9a45hn","category_id":"cljo9zkjq00074goifz3v6gea","_id":"cljo9zkjt000q4goi0k7wfn7p"},{"post_id":"cljo9zkjq00064goihyn69kzz","category_id":"cljo9zkjs000d4goi3nzx2545","_id":"cljo9zkjt000s4goia8rn0zud"},{"post_id":"cljo9zkjn00014goi59hyfxy3","category_id":"cljo9zkjq00074goifz3v6gea","_id":"cljo9zkju000v4goi6uso8nlj"},{"post_id":"cljo9zkjn00014goi59hyfxy3","category_id":"cljo9zkjt000p4goi5v02detb","_id":"cljo9zkju000x4goies5feufq"},{"post_id":"cljo9zkjr000b4goi8fzg64kj","category_id":"cljo9zkjq00074goifz3v6gea","_id":"cljo9zkju000z4goi9et71czk"},{"post_id":"cljo9zkjr000b4goi8fzg64kj","category_id":"cljo9zkjt000p4goi5v02detb","_id":"cljo9zkju00124goigp2i4zz0"},{"post_id":"cljwneykb0006m3oi131phei7","category_id":"cljo9zkjs000d4goi3nzx2545","_id":"cljwneykd0009m3oicrled1fj"}],"PostTag":[{"post_id":"cljo9zkjl00004goifkkd2ktv","tag_id":"cljo9zkjp00034goi6etuf0oo","_id":"cljo9zkjr00094goi4ps73yw3"},{"post_id":"cljo9zkjn00014goi59hyfxy3","tag_id":"cljo9zkjq00084goidlhtdo5k","_id":"cljo9zkjt000j4goi22tef3sg"},{"post_id":"cljo9zkjn00014goi59hyfxy3","tag_id":"cljo9zkjs000e4goi3yj4hcgl","_id":"cljo9zkjt000l4goibu8x3t4b"},{"post_id":"cljo9zkjp00044goibj6kewct","tag_id":"cljo9zkjs000i4goi109ihmrk","_id":"cljo9zkju000y4goigwbmflsg"},{"post_id":"cljo9zkjp00044goibj6kewct","tag_id":"cljo9zkjs000e4goi3yj4hcgl","_id":"cljo9zkju00104goih2wp813r"},{"post_id":"cljo9zkjp00044goibj6kewct","tag_id":"cljo9zkjq00084goidlhtdo5k","_id":"cljo9zkju00134goi3g3l1ya3"},{"post_id":"cljo9zkjp00044goibj6kewct","tag_id":"cljo9zkjt000u4goih39t9zrk","_id":"cljo9zkju00144goid10catlw"},{"post_id":"cljo9zkjp00054goi3n9a45hn","tag_id":"cljo9zkjt000u4goih39t9zrk","_id":"cljo9zkju00164goi0gv268px"},{"post_id":"cljo9zkjp00054goi3n9a45hn","tag_id":"cljo9zkju00114goieubl5921","_id":"cljo9zkju00174goidmah9yhy"},{"post_id":"cljo9zkjq00064goihyn69kzz","tag_id":"cljo9zkjs000i4goi109ihmrk","_id":"cljo9zkjv001c4goici9xds7j"},{"post_id":"cljo9zkjq00064goihyn69kzz","tag_id":"cljo9zkjs000e4goi3yj4hcgl","_id":"cljo9zkjv001d4goihkj69l7i"},{"post_id":"cljo9zkjq00064goihyn69kzz","tag_id":"cljo9zkjq00084goidlhtdo5k","_id":"cljo9zkjv001f4goihdtue80h"},{"post_id":"cljo9zkjq00064goihyn69kzz","tag_id":"cljo9zkjt000u4goih39t9zrk","_id":"cljo9zkjv001g4goi0huc28cz"},{"post_id":"cljo9zkjr000a4goihf3c0c7k","tag_id":"cljo9zkjv001b4goi1sdxcxze","_id":"cljo9zkjw001k4goie1z56x1s"},{"post_id":"cljo9zkjr000a4goihf3c0c7k","tag_id":"cljo9zkjv001e4goi6oi7esl6","_id":"cljo9zkjw001l4goi2hjw6sry"},{"post_id":"cljo9zkjr000a4goihf3c0c7k","tag_id":"cljo9zkjv001h4goiah5gceqr","_id":"cljo9zkjw001n4goi94n5fctc"},{"post_id":"cljo9zkjr000a4goihf3c0c7k","tag_id":"cljo9zkjw001i4goi4zi09k5x","_id":"cljo9zkjw001o4goi95y7cjn9"},{"post_id":"cljo9zkjr000b4goi8fzg64kj","tag_id":"cljo9zkjq00084goidlhtdo5k","_id":"cljo9zkjx001q4goid5bicl1b"},{"post_id":"cljo9zkjr000b4goi8fzg64kj","tag_id":"cljo9zkjs000e4goi3yj4hcgl","_id":"cljo9zkjx001r4goi536vf7nc"},{"post_id":"cljo9zkjs000f4goihc0y4xef","tag_id":"cljo9zkjw001m4goi642d5x8a","_id":"cljo9zkjx001s4goiean537tz"},{"post_id":"cljo9zkjs000f4goihc0y4xef","tag_id":"cljo9zkjx001p4goihwt36hpf","_id":"cljo9zkjx001t4goic1bw1e2l"},{"post_id":"cljwneykb0006m3oi131phei7","tag_id":"cljo9zkjs000i4goi109ihmrk","_id":"cljwneykc0007m3oi93z1ewpb"},{"post_id":"cljwneykb0006m3oi131phei7","tag_id":"cljo9zkjs000e4goi3yj4hcgl","_id":"cljwneykd0008m3oi1xwy8avl"},{"post_id":"cljwneykb0006m3oi131phei7","tag_id":"cljo9zkjq00084goidlhtdo5k","_id":"cljwneykd000am3oick7zfijn"},{"post_id":"cljwneykb0006m3oi131phei7","tag_id":"cljo9zkjt000u4goih39t9zrk","_id":"cljwneykd000bm3oi0yvtc6ga"}],"Tag":[{"name":"阅读","_id":"cljo9zkjp00034goi6etuf0oo"},{"name":"Aliyun","_id":"cljo9zkjq00084goidlhtdo5k"},{"name":"Kubernetes","_id":"cljo9zkjs000e4goi3yj4hcgl"},{"name":"架构","_id":"cljo9zkjs000i4goi109ihmrk"},{"name":"Java","_id":"cljo9zkjt000u4goih39t9zrk"},{"name":"Spring","_id":"cljo9zkju00114goieubl5921"},{"name":"ubuntu","_id":"cljo9zkjv001b4goi1sdxcxze"},{"name":"node.js","_id":"cljo9zkjv001e4goi6oi7esl6"},{"name":"nginx","_id":"cljo9zkjv001h4goiah5gceqr"},{"name":"mongodb","_id":"cljo9zkjw001i4goi4zi09k5x"},{"name":"java","_id":"cljo9zkjw001m4goi642d5x8a"},{"name":"generic","_id":"cljo9zkjx001p4goihwt36hpf"}]}}